{"traceEvents": [{"ph": "M", "pid": 60509, "tid": 60509, "name": "process_name", "args": {"name": "MainProcess"}}, {"ph": "M", "pid": 60509, "tid": 1094333, "name": "thread_name", "args": {"name": "IOPub"}}, {"ph": "M", "pid": 60509, "tid": 1094286, "name": "thread_name", "args": {"name": "MainThread"}}, {"pid": 60509, "tid": 1094286, "ts": 67825317325.164, "ph": "X", "dur": 0.41666666658220797, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317324.664, "ph": "X", "dur": 5.2083333322776, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317330.748, "ph": "X", "dur": 0.12499999997466239, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317330.206, "ph": "X", "dur": 0.7499999998479743, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317324.206, "ph": "X", "dur": 6.9166666652646525, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317332.164, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317331.789, "ph": "X", "dur": 0.5833333332150912, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317332.914, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317332.581, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317331.414, "ph": "X", "dur": 1.7916666663034944, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317334.123, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317333.748, "ph": "X", "dur": 0.5416666665568703, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317334.831, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317334.498, "ph": "X", "dur": 0.5416666665568703, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317333.373, "ph": "X", "dur": 1.7499999996452735, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317323.456, "ph": "X", "dur": 11.749999997618264, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317336.498, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317336.123, "ph": "X", "dur": 0.5416666665568703, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317337.206, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317336.873, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317335.789, "ph": "X", "dur": 1.7083333329870527, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317338.414, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317338.039, "ph": "X", "dur": 0.5416666665568703, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317339.123, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317338.789, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317337.706, "ph": "X", "dur": 1.6666666663288319, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317340.289, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317339.914, "ph": "X", "dur": 0.5416666665568703, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317341.081, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317340.664, "ph": "X", "dur": 0.5833333332150912, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317339.581, "ph": "X", "dur": 1.7499999996452735, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317335.414, "ph": "X", "dur": 6.041666665442016, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317342.748, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317342.373, "ph": "X", "dur": 0.5833333332150912, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317343.498, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317343.123, "ph": "X", "dur": 0.5416666665568703, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317341.998, "ph": "X", "dur": 1.7499999996452735, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317344.706, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317344.331, "ph": "X", "dur": 0.5416666665568703, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317345.456, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317345.081, "ph": "X", "dur": 0.5416666665568703, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317343.998, "ph": "X", "dur": 1.7083333329870527, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317346.623, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317346.248, "ph": "X", "dur": 0.5416666665568703, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317347.331, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317346.998, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317345.914, "ph": "X", "dur": 1.7083333329870527, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317341.623, "ph": "X", "dur": 6.083333332100237, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317349.581, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317348.664, "ph": "X", "dur": 1.0833333331137407, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317350.289, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317349.914, "ph": "X", "dur": 0.5416666665568703, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317348.248, "ph": "X", "dur": 2.3333333328603647, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317351.456, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317351.123, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317352.164, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317351.831, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317350.748, "ph": "X", "dur": 1.6666666663288319, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317353.289, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317352.956, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317353.998, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317353.664, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317352.623, "ph": "X", "dur": 1.6666666663288319, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317347.914, "ph": "X", "dur": 6.458333332024224, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317322.664, "ph": "X", "dur": 31.833333326880688, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317356.039, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317355.706, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317356.748, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317356.414, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317355.373, "ph": "X", "dur": 1.624999999670611, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317357.831, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317357.498, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317358.539, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317358.164, "ph": "X", "dur": 0.5416666665568703, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317357.164, "ph": "X", "dur": 1.624999999670611, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317359.664, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317359.331, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317360.539, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317359.998, "ph": "X", "dur": 0.7083333331897536, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317358.956, "ph": "X", "dur": 1.8333333329617152, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317355.039, "ph": "X", "dur": 5.874999998809132, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317362.164, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317361.831, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317362.831, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317362.498, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317361.498, "ph": "X", "dur": 1.5833333330123902, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317363.873, "ph": "X", "dur": 0.12499999997466239, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317363.581, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317364.581, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317364.248, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317363.248, "ph": "X", "dur": 1.5833333330123902, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317365.706, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317365.373, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317366.373, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317366.081, "ph": "X", "dur": 0.4583333332404288, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317365.039, "ph": "X", "dur": 1.5833333330123902, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317361.081, "ph": "X", "dur": 5.6666666655180284, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317367.873, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317367.581, "ph": "X", "dur": 0.4583333332404288, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317368.581, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317368.248, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317367.206, "ph": "X", "dur": 1.624999999670611, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317369.664, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317369.331, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317370.331, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317369.998, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317368.998, "ph": "X", "dur": 1.624999999670611, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317371.498, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317371.123, "ph": "X", "dur": 0.5416666665568703, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317372.206, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317371.873, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317370.789, "ph": "X", "dur": 1.6666666663288319, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317366.914, "ph": "X", "dur": 5.624999998859807, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317373.706, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317373.373, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317374.373, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317374.039, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317373.039, "ph": "X", "dur": 1.5833333330123902, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317375.456, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317375.123, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317376.164, "ph": "X", "dur": 0.041666666658220795, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317375.831, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317374.789, "ph": "X", "dur": 1.624999999670611, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317377.206, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317376.873, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317377.873, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317377.539, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317376.581, "ph": "X", "dur": 1.5416666663541696, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317372.706, "ph": "X", "dur": 5.541666665543366, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317354.664, "ph": "X", "dur": 23.666666661869414, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317379.914, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317379.623, "ph": "X", "dur": 0.4583333332404288, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317380.623, "ph": "X", "dur": 0.041666666658220795, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317380.248, "ph": "X", "dur": 0.5416666665568703, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317379.248, "ph": "X", "dur": 1.624999999670611, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317381.706, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317381.373, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317382.414, "ph": "X", "dur": 0.041666666658220795, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317382.081, "ph": "X", "dur": 0.4583333332404288, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317381.039, "ph": "X", "dur": 1.624999999670611, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317383.498, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317383.164, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317384.164, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317383.831, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317382.831, "ph": "X", "dur": 1.5833333330123902, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317378.873, "ph": "X", "dur": 5.624999998859807, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317385.748, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317385.414, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317386.414, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317386.081, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317384.998, "ph": "X", "dur": 1.6666666663288319, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317387.498, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317387.164, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317388.164, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317387.831, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317386.831, "ph": "X", "dur": 1.5833333330123902, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317389.248, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317388.956, "ph": "X", "dur": 0.4583333332404288, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317389.914, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317389.581, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317388.623, "ph": "X", "dur": 1.5416666663541696, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317384.664, "ph": "X", "dur": 5.583333332201587, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317391.414, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317391.081, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317392.081, "ph": "X", "dur": 0.041666666658220795, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317391.748, "ph": "X", "dur": 0.4583333332404288, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317390.748, "ph": "X", "dur": 1.5833333330123902, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317393.123, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317392.789, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317393.789, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317393.456, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317392.498, "ph": "X", "dur": 1.5833333330123902, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317394.873, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317394.581, "ph": "X", "dur": 0.4583333332404288, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317395.539, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317395.206, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317394.248, "ph": "X", "dur": 1.5416666663541696, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317390.414, "ph": "X", "dur": 5.458333332226925, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317397.039, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317396.706, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317397.706, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317397.373, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317396.373, "ph": "X", "dur": 1.5833333330123902, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317398.748, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317398.456, "ph": "X", "dur": 0.4583333332404288, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317399.414, "ph": "X", "dur": 0.041666666658220795, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317399.081, "ph": "X", "dur": 0.4583333332404288, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317398.123, "ph": "X", "dur": 3.499999999290547, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317402.456, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317402.123, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317403.123, "ph": "X", "dur": 0.041666666658220795, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317402.789, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317401.831, "ph": "X", "dur": 1.5416666663541696, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317396.039, "ph": "X", "dur": 7.416666665163302, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317378.539, "ph": "X", "dur": 24.999999994932477, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317405.164, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317404.873, "ph": "X", "dur": 0.4583333332404288, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317405.831, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317405.498, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317404.539, "ph": "X", "dur": 1.5416666663541696, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317406.914, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317406.581, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317407.539, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317407.248, "ph": "X", "dur": 0.4583333332404288, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317406.289, "ph": "X", "dur": 1.5416666663541696, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317408.623, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317408.289, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317409.289, "ph": "X", "dur": 0.041666666658220795, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317408.956, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317407.998, "ph": "X", "dur": 1.5416666663541696, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317404.248, "ph": "X", "dur": 5.374999998910483, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317410.789, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317410.456, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317411.414, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317411.123, "ph": "X", "dur": 0.4583333332404288, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317410.123, "ph": "X", "dur": 1.5416666663541696, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317412.498, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317412.164, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317413.164, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317412.831, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317411.873, "ph": "X", "dur": 1.5416666663541696, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317414.248, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317413.914, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317414.956, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317414.581, "ph": "X", "dur": 0.5416666665568703, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317413.623, "ph": "X", "dur": 1.5833333330123902, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317409.789, "ph": "X", "dur": 5.499999998885145, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317416.456, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317416.123, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317417.081, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317416.789, "ph": "X", "dur": 0.4583333332404288, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317415.789, "ph": "X", "dur": 1.5833333330123902, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317418.164, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317417.831, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317418.831, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317418.498, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317417.539, "ph": "X", "dur": 1.5416666663541696, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317419.914, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317419.581, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317420.581, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317420.248, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317419.248, "ph": "X", "dur": 1.5833333330123902, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317415.456, "ph": "X", "dur": 5.458333332226925, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317421.998, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317421.706, "ph": "X", "dur": 0.4583333332404288, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317422.664, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317422.331, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317421.373, "ph": "X", "dur": 1.5416666663541696, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317423.706, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317423.414, "ph": "X", "dur": 0.4583333332404288, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317424.414, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317424.081, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317423.081, "ph": "X", "dur": 1.624999999670611, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317461.039, "ph": "X", "dur": 0.24999999994932479, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317460.748, "ph": "X", "dur": 1.0833333331137407, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317462.164, "ph": "X", "dur": 0.041666666658220795, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317461.998, "ph": "X", "dur": 0.2916666666075456, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317459.081, "ph": "X", "dur": 3.249999999341222, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317421.039, "ph": "X", "dur": 41.333333324955035, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317403.914, "ph": "X", "dur": 58.58333332145844, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317463.498, "ph": "X", "dur": 0.041666666658220795, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317463.373, "ph": "X", "dur": 0.20833333329110398, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317463.789, "ph": "X", "dur": 0.041666666658220795, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317463.664, "ph": "X", "dur": 0.20833333329110398, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317463.248, "ph": "X", "dur": 0.6666666665315327, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317464.206, "ph": "X", "dur": 0.041666666658220795, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317464.081, "ph": "X", "dur": 0.20833333329110398, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317464.456, "ph": "X", "dur": 0.041666666658220795, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317464.373, "ph": "X", "dur": 0.16666666663288318, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317463.998, "ph": "X", "dur": 0.5833333332150912, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317473.539, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317472.498, "ph": "X", "dur": 1.3333333330630655, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317474.498, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317474.164, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317464.664, "ph": "X", "dur": 10.124999997947654, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317463.123, "ph": "X", "dur": 11.749999997618264, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317476.039, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317475.748, "ph": "X", "dur": 0.4583333332404288, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317476.706, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317476.414, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317475.414, "ph": "X", "dur": 1.5833333330123902, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317477.789, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317477.456, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317478.456, "ph": "X", "dur": 0.041666666658220795, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317478.123, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317477.164, "ph": "X", "dur": 1.5416666663541696, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317479.498, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317479.206, "ph": "X", "dur": 0.4583333332404288, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317480.164, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317479.831, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317478.873, "ph": "X", "dur": 1.5833333330123902, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317475.081, "ph": "X", "dur": 5.458333332226925, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317481.664, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317481.331, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317482.289, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317481.998, "ph": "X", "dur": 0.4583333332404288, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317481.039, "ph": "X", "dur": 1.4999999996959485, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317483.373, "ph": "X", "dur": 0.041666666658220795, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317483.039, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317484.039, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317483.706, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317482.706, "ph": "X", "dur": 1.5833333330123902, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317485.164, "ph": "X", "dur": 0.041666666658220795, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317484.789, "ph": "X", "dur": 0.5416666665568703, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317485.873, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317485.539, "ph": "X", "dur": 0.5416666665568703, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317484.456, "ph": "X", "dur": 1.7083333329870527, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317480.706, "ph": "X", "dur": 5.541666665543366, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317487.498, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317487.164, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317488.164, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317487.831, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317486.789, "ph": "X", "dur": 1.624999999670611, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317489.248, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317488.914, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317489.914, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317489.623, "ph": "X", "dur": 0.49999999989864957, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317488.581, "ph": "X", "dur": 1.624999999670611, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317503.706, "ph": "X", "dur": 0.2916666666075456, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317490.706, "ph": "X", "dur": 13.6249999972382, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317505.623, "ph": "X", "dur": 0.08333333331644159, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317504.664, "ph": "X", "dur": 1.1666666664301824, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317490.373, "ph": "X", "dur": 15.583333330174579, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317486.456, "ph": "X", "dur": 19.666666662680218, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317462.998, "ph": "X", "dur": 43.24999999123319, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317319.623, "ph": "X", "dur": 186.83333329546207, "name": "factorial_recur (/var/folders/jc/dkfbzy8d0934z9dksxw3s0tr0000gn/T/ipykernel_60509/4142474121.py:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317532.664, "ph": "X", "dur": 0.41666666658220797, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317544.414, "ph": "X", "dur": 0.4583333332404288, "name": "posix.getpid", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317543.581, "ph": "X", "dur": 2.0416666662528193, "name": "OutStream._is_master_process (/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py:519)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317599.164, "ph": "X", "dur": 1.2083333330884032, "name": "_io.StringIO.write", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317600.831, "ph": "X", "dur": 0.5416666665568703, "name": "_thread.RLock.__exit__", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317611.581, "ph": "X", "dur": 0.2916666666075456, "name": "Event.is_set (/opt/anaconda3/lib/python3.12/threading.py:601)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317614.206, "ph": "X", "dur": 1.2499999997466238, "name": "_thread.lock.acquire", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317613.706, "ph": "X", "dur": 2.0416666662528193, "name": "Thread._wait_for_tstate_lock (/opt/anaconda3/lib/python3.12/threading.py:1155)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317610.373, "ph": "X", "dur": 5.70833333217625, "name": "Thread.is_alive (/opt/anaconda3/lib/python3.12/threading.py:1222)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317616.706, "ph": "X", "dur": 0.37499999992398714, "name": "collections.deque.append", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317619.039, "ph": "X", "dur": 1.8333333329617152, "name": "IOPubThread._event_pipe (/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py:137)", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317718.873, "ph": "X", "dur": 0.2916666666075456, "name": "collections.deque.popleft", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317725.456, "ph": "X", "dur": 0.12499999997466239, "name": "IOPubThread.closed (/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py:254)", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317727.331, "ph": "X", "dur": 0.24999999994932479, "name": "posix.getpid", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317727.206, "ph": "X", "dur": 0.7499999998479743, "name": "IOPubThread._is_master_process (/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py:212)", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317726.623, "ph": "X", "dur": 1.4999999996959485, "name": "IOPubThread._check_mp_mode (/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py:215)", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317732.623, "ph": "X", "dur": 0.7499999998479743, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317733.789, "ph": "X", "dur": 0.12499999997466239, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317734.331, "ph": "X", "dur": 0.12499999997466239, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317734.748, "ph": "X", "dur": 0.08333333331644159, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317735.039, "ph": "X", "dur": 0.08333333331644159, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317735.539, "ph": "X", "dur": 0.08333333331644159, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317735.914, "ph": "X", "dur": 0.08333333331644159, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317755.581, "ph": "X", "dur": 1.1249999997719615, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317757.539, "ph": "X", "dur": 0.08333333331644159, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317754.706, "ph": "X", "dur": 3.1249999993665596, "name": "Flag._get_value (/opt/anaconda3/lib/python3.12/enum.py:1544)", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317758.914, "ph": "X", "dur": 0.041666666658220795, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317758.706, "ph": "X", "dur": 0.6666666665315327, "name": "Flag._get_value (/opt/anaconda3/lib/python3.12/enum.py:1544)", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317760.039, "ph": "X", "dur": 0.24999999994932479, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317760.539, "ph": "X", "dur": 0.08333333331644159, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317759.914, "ph": "X", "dur": 0.9166666664808576, "name": "Flag._get_value (/opt/anaconda3/lib/python3.12/enum.py:1544)", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317772.706, "ph": "X", "dur": 1.2916666664048448, "name": "Enum.__new__ (/opt/anaconda3/lib/python3.12/enum.py:1129)", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317768.289, "ph": "X", "dur": 5.999999998783794, "name": "EnumType.__call__ (/opt/anaconda3/lib/python3.12/enum.py:726)", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317748.373, "ph": "X", "dur": 26.291666661337324, "name": "Flag.__or__ (/opt/anaconda3/lib/python3.12/enum.py:1551)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317623.289, "ph": "X", "dur": 168.49999996584492, "name": "Socket.send (/opt/anaconda3/lib/python3.12/site-packages/zmq/sugar/socket.py:621)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317607.998, "ph": "X", "dur": 184.12499996267772, "name": "IOPubThread.schedule (/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py:258)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317603.914, "ph": "X", "dur": 188.49999996179088, "name": "OutStream._schedule_flush (/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py:546)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317793.123, "ph": "X", "dur": 0.6666666665315327, "name": "builtins.len", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317531.664, "ph": "X", "dur": 262.4166666134746, "name": "OutStream.write (/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py:624)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317795.581, "ph": "X", "dur": 0.20833333329110398, "name": "builtins.isinstance", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317798.498, "ph": "X", "dur": 0.16666666663288318, "name": "posix.getpid", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317798.373, "ph": "X", "dur": 0.7916666665061951, "name": "OutStream._is_master_process (/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py:519)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317800.581, "ph": "X", "dur": 0.5833333332150912, "name": "_io.StringIO.write", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317801.539, "ph": "X", "dur": 0.2916666666075456, "name": "_thread.RLock.__exit__", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317802.623, "ph": "X", "dur": 0.16666666663288318, "name": "OutStream._schedule_flush (/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py:546)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317802.998, "ph": "X", "dur": 0.12499999997466239, "name": "builtins.len", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317795.414, "ph": "X", "dur": 7.9166666650619515, "name": "OutStream.write (/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py:624)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317508.748, "ph": "X", "dur": 303.62499993845495, "name": "builtins.print", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317306.623, "ph": "X", "dur": 506.0416665640916, "name": "<module> (<string>:1)", "cat": "FEE"}, {"pid": 60509, "tid": 1094286, "ts": 67825317153.206, "ph": "X", "dur": 662.5416665323688, "name": "builtins.exec", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317775.623, "ph": "B", "name": "Socket.send (/opt/anaconda3/lib/python3.12/site-packages/zmq/sugar/socket.py:621)", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317729.998, "ph": "B", "name": "Socket.send_multipart (/opt/anaconda3/lib/python3.12/site-packages/zmq/sugar/socket.py:698)", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317724.789, "ph": "B", "name": "IOPubThread._really_send (/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py:277)", "cat": "FEE"}, {"pid": 60509, "tid": 1094333, "ts": 67825317721.748, "ph": "B", "name": "IOPubThread.send_multipart.<locals>.<lambda> (/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py:275)", "cat": "FEE"}], "viztracer_metadata": {"version": "1.0.0", "overflow": false, "baseTimeNanoseconds": 1733175017620416185}, "file_info": {"files": {"/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py": ["\"\"\"Wrappers for forwarding stdout/stderr over zmq\"\"\"\n\n# Copyright (c) IPython Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport asyncio\nimport atexit\nimport io\nimport os\nimport sys\nimport threading\nimport traceback\nimport warnings\nfrom binascii import b2a_hex\nfrom collections import deque\nfrom io import StringIO, TextIOBase\nfrom threading import local\nfrom typing import Any, Callable, Deque, Dict, Optional\n\nimport zmq\nfrom jupyter_client.session import extract_header\nfrom tornado.ioloop import IOLoop\nfrom zmq.eventloop.zmqstream import ZMQStream\n\n# -----------------------------------------------------------------------------\n# Globals\n# -----------------------------------------------------------------------------\n\nMASTER = 0\nCHILD = 1\n\nPIPE_BUFFER_SIZE = 1000\n\n# -----------------------------------------------------------------------------\n# IO classes\n# -----------------------------------------------------------------------------\n\n\nclass IOPubThread:\n    \"\"\"An object for sending IOPub messages in a background thread\n\n    Prevents a blocking main thread from delaying output from threads.\n\n    IOPubThread(pub_socket).background_socket is a Socket-API-providing object\n    whose IO is always run in a thread.\n    \"\"\"\n\n    def __init__(self, socket, pipe=False):\n        \"\"\"Create IOPub thread\n\n        Parameters\n        ----------\n        socket : zmq.PUB Socket\n            the socket on which messages will be sent.\n        pipe : bool\n            Whether this process should listen for IOPub messages\n            piped from subprocesses.\n        \"\"\"\n        self.socket = socket\n        self._stopped = False\n        self.background_socket = BackgroundSocket(self)\n        self._master_pid = os.getpid()\n        self._pipe_flag = pipe\n        self.io_loop = IOLoop(make_current=False)\n        if pipe:\n            self._setup_pipe_in()\n        self._local = threading.local()\n        self._events: Deque[Callable[..., Any]] = deque()\n        self._event_pipes: Dict[threading.Thread, Any] = {}\n        self._event_pipe_gc_lock: threading.Lock = threading.Lock()\n        self._event_pipe_gc_seconds: float = 10\n        self._event_pipe_gc_task: Optional[asyncio.Task[Any]] = None\n        self._setup_event_pipe()\n        self.thread = threading.Thread(target=self._thread_main, name=\"IOPub\")\n        self.thread.daemon = True\n        self.thread.pydev_do_not_trace = True  # type:ignore[attr-defined]\n        self.thread.is_pydev_daemon_thread = True  # type:ignore[attr-defined]\n        self.thread.name = \"IOPub\"\n\n    def _thread_main(self):\n        \"\"\"The inner loop that's actually run in a thread\"\"\"\n\n        def _start_event_gc():\n            self._event_pipe_gc_task = asyncio.ensure_future(self._run_event_pipe_gc())\n\n        self.io_loop.run_sync(_start_event_gc)\n\n        if not self._stopped:\n            # avoid race if stop called before start thread gets here\n            # probably only comes up in tests\n            self.io_loop.start()\n\n        if self._event_pipe_gc_task is not None:\n            # cancel gc task to avoid pending task warnings\n            async def _cancel():\n                self._event_pipe_gc_task.cancel()  # type:ignore[union-attr]\n\n            if not self._stopped:\n                self.io_loop.run_sync(_cancel)\n            else:\n                self._event_pipe_gc_task.cancel()\n\n        self.io_loop.close(all_fds=True)\n\n    def _setup_event_pipe(self):\n        \"\"\"Create the PULL socket listening for events that should fire in this thread.\"\"\"\n        ctx = self.socket.context\n        pipe_in = ctx.socket(zmq.PULL)\n        pipe_in.linger = 0\n\n        _uuid = b2a_hex(os.urandom(16)).decode(\"ascii\")\n        iface = self._event_interface = \"inproc://%s\" % _uuid\n        pipe_in.bind(iface)\n        self._event_puller = ZMQStream(pipe_in, self.io_loop)\n        self._event_puller.on_recv(self._handle_event)\n\n    async def _run_event_pipe_gc(self):\n        \"\"\"Task to run event pipe gc continuously\"\"\"\n        while True:\n            await asyncio.sleep(self._event_pipe_gc_seconds)\n            try:\n                await self._event_pipe_gc()\n            except Exception as e:\n                print(f\"Exception in IOPubThread._event_pipe_gc: {e}\", file=sys.__stderr__)\n\n    async def _event_pipe_gc(self):\n        \"\"\"run a single garbage collection on event pipes\"\"\"\n        if not self._event_pipes:\n            # don't acquire the lock if there's nothing to do\n            return\n        with self._event_pipe_gc_lock:\n            for thread, socket in list(self._event_pipes.items()):\n                if not thread.is_alive():\n                    socket.close()\n                    del self._event_pipes[thread]\n\n    @property\n    def _event_pipe(self):\n        \"\"\"thread-local event pipe for signaling events that should be processed in the thread\"\"\"\n        try:\n            event_pipe = self._local.event_pipe\n        except AttributeError:\n            # new thread, new event pipe\n            ctx = self.socket.context\n            event_pipe = ctx.socket(zmq.PUSH)\n            event_pipe.linger = 0\n            event_pipe.connect(self._event_interface)\n            self._local.event_pipe = event_pipe\n            # associate event pipes to their threads\n            # so they can be closed explicitly\n            # implicit close on __del__ throws a ResourceWarning\n            with self._event_pipe_gc_lock:\n                self._event_pipes[threading.current_thread()] = event_pipe\n        return event_pipe\n\n    def _handle_event(self, msg):\n        \"\"\"Handle an event on the event pipe\n\n        Content of the message is ignored.\n\n        Whenever *an* event arrives on the event stream,\n        *all* waiting events are processed in order.\n        \"\"\"\n        # freeze event count so new writes don't extend the queue\n        # while we are processing\n        n_events = len(self._events)\n        for _ in range(n_events):\n            event_f = self._events.popleft()\n            event_f()\n\n    def _setup_pipe_in(self):\n        \"\"\"setup listening pipe for IOPub from forked subprocesses\"\"\"\n        ctx = self.socket.context\n\n        # use UUID to authenticate pipe messages\n        self._pipe_uuid = os.urandom(16)\n\n        pipe_in = ctx.socket(zmq.PULL)\n        pipe_in.linger = 0\n\n        try:\n            self._pipe_port = pipe_in.bind_to_random_port(\"tcp://127.0.0.1\")\n        except zmq.ZMQError as e:\n            warnings.warn(\n                \"Couldn't bind IOPub Pipe to 127.0.0.1: %s\" % e\n                + \"\\nsubprocess output will be unavailable.\",\n                stacklevel=2,\n            )\n            self._pipe_flag = False\n            pipe_in.close()\n            return\n        self._pipe_in = ZMQStream(pipe_in, self.io_loop)\n        self._pipe_in.on_recv(self._handle_pipe_msg)\n\n    def _handle_pipe_msg(self, msg):\n        \"\"\"handle a pipe message from a subprocess\"\"\"\n        if not self._pipe_flag or not self._is_master_process():\n            return\n        if msg[0] != self._pipe_uuid:\n            print(\"Bad pipe message: %s\", msg, file=sys.__stderr__)\n            return\n        self.send_multipart(msg[1:])\n\n    def _setup_pipe_out(self):\n        # must be new context after fork\n        ctx = zmq.Context()\n        pipe_out = ctx.socket(zmq.PUSH)\n        pipe_out.linger = 3000  # 3s timeout for pipe_out sends before discarding the message\n        pipe_out.connect(\"tcp://127.0.0.1:%i\" % self._pipe_port)\n        return ctx, pipe_out\n\n    def _is_master_process(self):\n        return os.getpid() == self._master_pid\n\n    def _check_mp_mode(self):\n        \"\"\"check for forks, and switch to zmq pipeline if necessary\"\"\"\n        if not self._pipe_flag or self._is_master_process():\n            return MASTER\n        return CHILD\n\n    def start(self):\n        \"\"\"Start the IOPub thread\"\"\"\n        self.thread.name = \"IOPub\"\n        self.thread.start()\n        # make sure we don't prevent process exit\n        # I'm not sure why setting daemon=True above isn't enough, but it doesn't appear to be.\n        atexit.register(self.stop)\n\n    def stop(self):\n        \"\"\"Stop the IOPub thread\"\"\"\n        self._stopped = True\n        if not self.thread.is_alive():\n            return\n        self.io_loop.add_callback(self.io_loop.stop)\n\n        self.thread.join(timeout=30)\n        if self.thread.is_alive():\n            # avoid infinite hang if stop fails\n            msg = \"IOPub thread did not terminate in 30 seconds\"\n            raise TimeoutError(msg)\n        # close *all* event pipes, created in any thread\n        # event pipes can only be used from other threads while self.thread.is_alive()\n        # so after thread.join, this should be safe\n        for _thread, event_pipe in self._event_pipes.items():\n            event_pipe.close()\n\n    def close(self):\n        \"\"\"Close the IOPub thread.\"\"\"\n        if self.closed:\n            return\n        self.socket.close()\n        self.socket = None\n\n    @property\n    def closed(self):\n        return self.socket is None\n\n    def schedule(self, f):\n        \"\"\"Schedule a function to be called in our IO thread.\n\n        If the thread is not running, call immediately.\n        \"\"\"\n        if self.thread.is_alive():\n            self._events.append(f)\n            # wake event thread (message content is ignored)\n            self._event_pipe.send(b\"\")\n        else:\n            f()\n\n    def send_multipart(self, *args, **kwargs):\n        \"\"\"send_multipart schedules actual zmq send in my thread.\n\n        If my thread isn't running (e.g. forked process), send immediately.\n        \"\"\"\n        self.schedule(lambda: self._really_send(*args, **kwargs))\n\n    def _really_send(self, msg, *args, **kwargs):\n        \"\"\"The callback that actually sends messages\"\"\"\n        if self.closed:\n            return\n\n        mp_mode = self._check_mp_mode()\n\n        if mp_mode != CHILD:\n            # we are master, do a regular send\n            self.socket.send_multipart(msg, *args, **kwargs)\n        else:\n            # we are a child, pipe to master\n            # new context/socket for every pipe-out\n            # since forks don't teardown politely, use ctx.term to ensure send has completed\n            ctx, pipe_out = self._setup_pipe_out()\n            pipe_out.send_multipart([self._pipe_uuid, *msg], *args, **kwargs)\n            pipe_out.close()\n            ctx.term()\n\n\nclass BackgroundSocket:\n    \"\"\"Wrapper around IOPub thread that provides zmq send[_multipart]\"\"\"\n\n    io_thread = None\n\n    def __init__(self, io_thread):\n        \"\"\"Initialize the socket.\"\"\"\n        self.io_thread = io_thread\n\n    def __getattr__(self, attr):\n        \"\"\"Wrap socket attr access for backward-compatibility\"\"\"\n        if attr.startswith(\"__\") and attr.endswith(\"__\"):\n            # don't wrap magic methods\n            super().__getattr__(attr)  # type:ignore[misc]\n        assert self.io_thread is not None\n        if hasattr(self.io_thread.socket, attr):\n            warnings.warn(\n                f\"Accessing zmq Socket attribute {attr} on BackgroundSocket\"\n                f\" is deprecated since ipykernel 4.3.0\"\n                f\" use .io_thread.socket.{attr}\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            return getattr(self.io_thread.socket, attr)\n        return super().__getattr__(attr)  # type:ignore[misc]\n\n    def __setattr__(self, attr, value):\n        \"\"\"Set an attribute on the socket.\"\"\"\n        if attr == \"io_thread\" or (attr.startswith(\"__\") and attr.endswith(\"__\")):\n            super().__setattr__(attr, value)\n        else:\n            warnings.warn(\n                f\"Setting zmq Socket attribute {attr} on BackgroundSocket\"\n                f\" is deprecated since ipykernel 4.3.0\"\n                f\" use .io_thread.socket.{attr}\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            assert self.io_thread is not None\n            setattr(self.io_thread.socket, attr, value)\n\n    def send(self, msg, *args, **kwargs):\n        \"\"\"Send a message to the socket.\"\"\"\n        return self.send_multipart([msg], *args, **kwargs)\n\n    def send_multipart(self, *args, **kwargs):\n        \"\"\"Schedule send in IO thread\"\"\"\n        assert self.io_thread is not None\n        return self.io_thread.send_multipart(*args, **kwargs)\n\n\nclass OutStream(TextIOBase):\n    \"\"\"A file like object that publishes the stream to a 0MQ PUB socket.\n\n    Output is handed off to an IO Thread\n    \"\"\"\n\n    # timeout for flush to avoid infinite hang\n    # in case of misbehavior\n    flush_timeout = 10\n    # The time interval between automatic flushes, in seconds.\n    flush_interval = 0.2\n    topic = None\n    encoding = \"UTF-8\"\n    _exc: Optional[Any] = None\n\n    def fileno(self):\n        \"\"\"\n        Things like subprocess will peak and write to the fileno() of stderr/stdout.\n        \"\"\"\n        if getattr(self, \"_original_stdstream_copy\", None) is not None:\n            return self._original_stdstream_copy\n        msg = \"fileno\"\n        raise io.UnsupportedOperation(msg)\n\n    def _watch_pipe_fd(self):\n        \"\"\"\n        We've redirected standards streams 0 and 1 into a pipe.\n\n        We need to watch in a thread and redirect them to the right places.\n\n        1) the ZMQ channels to show in notebook interfaces,\n        2) the original stdout/err, to capture errors in terminals.\n\n        We cannot schedule this on the ioloop thread, as this might be blocking.\n\n        \"\"\"\n\n        try:\n            bts = os.read(self._fid, PIPE_BUFFER_SIZE)\n            while bts and self._should_watch:\n                self.write(bts.decode(errors=\"replace\"))\n                os.write(self._original_stdstream_copy, bts)\n                bts = os.read(self._fid, PIPE_BUFFER_SIZE)\n        except Exception:\n            self._exc = sys.exc_info()\n\n    def __init__(\n        self,\n        session,\n        pub_thread,\n        name,\n        pipe=None,\n        echo=None,\n        *,\n        watchfd=True,\n        isatty=False,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        session : object\n            the session object\n        pub_thread : threading.Thread\n            the publication thread\n        name : str {'stderr', 'stdout'}\n            the name of the standard stream to replace\n        pipe : object\n            the pip object\n        echo : bool\n            whether to echo output\n        watchfd : bool (default, True)\n            Watch the file descriptor corresponding to the replaced stream.\n            This is useful if you know some underlying code will write directly\n            the file descriptor by its number. It will spawn a watching thread,\n            that will swap the give file descriptor for a pipe, read from the\n            pipe, and insert this into the current Stream.\n        isatty : bool (default, False)\n            Indication of whether this stream has terminal capabilities (e.g. can handle colors)\n\n        \"\"\"\n        if pipe is not None:\n            warnings.warn(\n                \"pipe argument to OutStream is deprecated and ignored since ipykernel 4.2.3.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n        # This is necessary for compatibility with Python built-in streams\n        self.session = session\n        if not isinstance(pub_thread, IOPubThread):\n            # Backward-compat: given socket, not thread. Wrap in a thread.\n            warnings.warn(\n                \"Since IPykernel 4.3, OutStream should be created with \"\n                \"IOPubThread, not %r\" % pub_thread,\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            pub_thread = IOPubThread(pub_thread)\n            pub_thread.start()\n        self.pub_thread = pub_thread\n        self.name = name\n        self.topic = b\"stream.\" + name.encode()\n        self.parent_header = {}\n        self._master_pid = os.getpid()\n        self._flush_pending = False\n        self._subprocess_flush_pending = False\n        self._io_loop = pub_thread.io_loop\n        self._buffer_lock = threading.RLock()\n        self._buffer = StringIO()\n        self.echo = None\n        self._isatty = bool(isatty)\n        self._should_watch = False\n        self._local = local()\n\n        if (\n            watchfd\n            and (\n                (sys.platform.startswith(\"linux\") or sys.platform.startswith(\"darwin\"))\n                # Pytest set its own capture. Don't redirect from within pytest.\n                and (\"PYTEST_CURRENT_TEST\" not in os.environ)\n            )\n            # allow forcing watchfd (mainly for tests)\n            or watchfd == \"force\"\n        ):\n            self._should_watch = True\n            self._setup_stream_redirects(name)\n\n        if echo:\n            if hasattr(echo, \"read\") and hasattr(echo, \"write\"):\n                # make sure we aren't trying to echo on the FD we're watching!\n                # that would cause an infinite loop, always echoing on itself\n                if self._should_watch:\n                    try:\n                        echo_fd = echo.fileno()\n                    except Exception:\n                        echo_fd = None\n\n                    if echo_fd is not None and echo_fd == self._original_stdstream_fd:\n                        # echo on the _copy_ we made during\n                        # this is the actual terminal FD now\n                        echo = io.TextIOWrapper(\n                            io.FileIO(\n                                self._original_stdstream_copy,\n                                \"w\",\n                            )\n                        )\n                self.echo = echo\n            else:\n                msg = \"echo argument must be a file-like object\"\n                raise ValueError(msg)\n\n    def isatty(self):\n        \"\"\"Return a bool indicating whether this is an 'interactive' stream.\n\n        Returns:\n            Boolean\n        \"\"\"\n        return self._isatty\n\n    def _setup_stream_redirects(self, name):\n        pr, pw = os.pipe()\n        fno = self._original_stdstream_fd = getattr(sys, name).fileno()\n        self._original_stdstream_copy = os.dup(fno)\n        os.dup2(pw, fno)\n\n        self._fid = pr\n\n        self._exc = None\n        self.watch_fd_thread = threading.Thread(target=self._watch_pipe_fd)\n        self.watch_fd_thread.daemon = True\n        self.watch_fd_thread.start()\n\n    def _is_master_process(self):\n        return os.getpid() == self._master_pid\n\n    def set_parent(self, parent):\n        \"\"\"Set the parent header.\"\"\"\n        self.parent_header = extract_header(parent)\n\n    def close(self):\n        \"\"\"Close the stream.\"\"\"\n        if self._should_watch:\n            self._should_watch = False\n            # thread won't wake unless there's something to read\n            # writing something after _should_watch will not be echoed\n            os.write(self._original_stdstream_fd, b\"\\0\")\n            self.watch_fd_thread.join()\n            # restore original FDs\n            os.dup2(self._original_stdstream_copy, self._original_stdstream_fd)\n            os.close(self._original_stdstream_copy)\n        if self._exc:\n            etype, value, tb = self._exc\n            traceback.print_exception(etype, value, tb)\n        self.pub_thread = None\n\n    @property\n    def closed(self):\n        return self.pub_thread is None\n\n    def _schedule_flush(self):\n        \"\"\"schedule a flush in the IO thread\n\n        call this on write, to indicate that flush should be called soon.\n        \"\"\"\n        if self._flush_pending:\n            return\n        self._flush_pending = True\n\n        # add_timeout has to be handed to the io thread via event pipe\n        def _schedule_in_thread():\n            self._io_loop.call_later(self.flush_interval, self._flush)\n\n        self.pub_thread.schedule(_schedule_in_thread)\n\n    def flush(self):\n        \"\"\"trigger actual zmq send\n\n        send will happen in the background thread\n        \"\"\"\n        if (\n            self.pub_thread\n            and self.pub_thread.thread is not None\n            and self.pub_thread.thread.is_alive()\n            and self.pub_thread.thread.ident != threading.current_thread().ident\n        ):\n            # request flush on the background thread\n            self.pub_thread.schedule(self._flush)\n            # wait for flush to actually get through, if we can.\n            evt = threading.Event()\n            self.pub_thread.schedule(evt.set)\n            # and give a timeout to avoid\n            if not evt.wait(self.flush_timeout):\n                # write directly to __stderr__ instead of warning because\n                # if this is happening sys.stderr may be the problem.\n                print(\"IOStream.flush timed out\", file=sys.__stderr__)\n        else:\n            self._flush()\n\n    def _flush(self):\n        \"\"\"This is where the actual send happens.\n\n        _flush should generally be called in the IO thread,\n        unless the thread has been destroyed (e.g. forked subprocess).\n        \"\"\"\n        self._flush_pending = False\n        self._subprocess_flush_pending = False\n\n        if self.echo is not None:\n            try:\n                self.echo.flush()\n            except OSError as e:\n                if self.echo is not sys.__stderr__:\n                    print(f\"Flush failed: {e}\", file=sys.__stderr__)\n\n        data = self._flush_buffer()\n        if data:\n            # FIXME: this disables Session's fork-safe check,\n            # since pub_thread is itself fork-safe.\n            # There should be a better way to do this.\n            self.session.pid = os.getpid()\n            content = {\"name\": self.name, \"text\": data}\n            msg = self.session.msg(\"stream\", content, parent=self.parent_header)\n\n            # Each transform either returns a new\n            # message or None. If None is returned,\n            # the message has been 'used' and we return.\n            for hook in self._hooks:\n                msg = hook(msg)\n                if msg is None:\n                    return\n\n            self.session.send(\n                self.pub_thread,\n                msg,\n                ident=self.topic,\n            )\n\n    def write(self, string: str) -> Optional[int]:  # type:ignore[override]\n        \"\"\"Write to current stream after encoding if necessary\n\n        Returns\n        -------\n        len : int\n            number of items from input parameter written to stream.\n\n        \"\"\"\n\n        if not isinstance(string, str):\n            msg = f\"write() argument must be str, not {type(string)}\"  # type:ignore[unreachable]\n            raise TypeError(msg)\n\n        if self.echo is not None:\n            try:\n                self.echo.write(string)\n            except OSError as e:\n                if self.echo is not sys.__stderr__:\n                    print(f\"Write failed: {e}\", file=sys.__stderr__)\n\n        if self.pub_thread is None:\n            msg = \"I/O operation on closed file\"\n            raise ValueError(msg)\n\n        is_child = not self._is_master_process()\n        # only touch the buffer in the IO thread to avoid races\n        with self._buffer_lock:\n            self._buffer.write(string)\n        if is_child:\n            # mp.Pool cannot be trusted to flush promptly (or ever),\n            # and this helps.\n            if self._subprocess_flush_pending:\n                return None\n            self._subprocess_flush_pending = True\n            # We can not rely on self._io_loop.call_later from a subprocess\n            self.pub_thread.schedule(self._flush)\n        else:\n            self._schedule_flush()\n\n        return len(string)\n\n    def writelines(self, sequence):\n        \"\"\"Write lines to the stream.\"\"\"\n        if self.pub_thread is None:\n            msg = \"I/O operation on closed file\"\n            raise ValueError(msg)\n        for string in sequence:\n            self.write(string)\n\n    def writable(self):\n        \"\"\"Test whether the stream is writable.\"\"\"\n        return True\n\n    def _flush_buffer(self):\n        \"\"\"clear the current buffer and return the current buffer data.\"\"\"\n        buf = self._rotate_buffer()\n        data = buf.getvalue()\n        buf.close()\n        return data\n\n    def _rotate_buffer(self):\n        \"\"\"Returns the current buffer and replaces it with an empty buffer.\"\"\"\n        with self._buffer_lock:\n            old_buffer = self._buffer\n            self._buffer = StringIO()\n        return old_buffer\n\n    @property\n    def _hooks(self):\n        if not hasattr(self._local, \"hooks\"):\n            # create new list for a new thread\n            self._local.hooks = []\n        return self._local.hooks\n\n    def register_hook(self, hook):\n        \"\"\"\n        Registers a hook with the thread-local storage.\n\n        Parameters\n        ----------\n        hook : Any callable object\n\n        Returns\n        -------\n        Either a publishable message, or `None`.\n        The hook callable must return a message from\n        the __call__ method if they still require the\n        `session.send` method to be called after transformation.\n        Returning `None` will halt that execution path, and\n        session.send will not be called.\n        \"\"\"\n        self._hooks.append(hook)\n\n    def unregister_hook(self, hook):\n        \"\"\"\n        Un-registers a hook with the thread-local storage.\n\n        Parameters\n        ----------\n        hook : Any callable object which has previously been\n            registered as a hook.\n\n        Returns\n        -------\n        bool - `True` if the hook was removed, `False` if it wasn't\n            found.\n        \"\"\"\n        try:\n            self._hooks.remove(hook)\n            return True\n        except ValueError:\n            return False\n", 736], "/opt/anaconda3/lib/python3.12/threading.py": ["\"\"\"Thread module emulating a subset of Java's threading model.\"\"\"\n\nimport os as _os\nimport sys as _sys\nimport _thread\nimport functools\n\nfrom time import monotonic as _time\nfrom _weakrefset import WeakSet\nfrom itertools import count as _count\ntry:\n    from _collections import deque as _deque\nexcept ImportError:\n    from collections import deque as _deque\n\n# Note regarding PEP 8 compliant names\n#  This threading model was originally inspired by Java, and inherited\n# the convention of camelCase function and method names from that\n# language. Those original names are not in any imminent danger of\n# being deprecated (even for Py3k),so this module provides them as an\n# alias for the PEP 8 compliant names\n# Note that using the new PEP 8 compliant names facilitates substitution\n# with the multiprocessing module, which doesn't provide the old\n# Java inspired names.\n\n__all__ = ['get_ident', 'active_count', 'Condition', 'current_thread',\n           'enumerate', 'main_thread', 'TIMEOUT_MAX',\n           'Event', 'Lock', 'RLock', 'Semaphore', 'BoundedSemaphore', 'Thread',\n           'Barrier', 'BrokenBarrierError', 'Timer', 'ThreadError',\n           'setprofile', 'settrace', 'local', 'stack_size',\n           'excepthook', 'ExceptHookArgs', 'gettrace', 'getprofile',\n           'setprofile_all_threads','settrace_all_threads']\n\n# Rename some stuff so \"from threading import *\" is safe\n_start_new_thread = _thread.start_new_thread\n_daemon_threads_allowed = _thread.daemon_threads_allowed\n_allocate_lock = _thread.allocate_lock\n_set_sentinel = _thread._set_sentinel\nget_ident = _thread.get_ident\ntry:\n    _is_main_interpreter = _thread._is_main_interpreter\nexcept AttributeError:\n    # See https://github.com/python/cpython/issues/112826.\n    # We can pretend a subinterpreter is the main interpreter for the\n    # sake of _shutdown(), since that only means we do not wait for the\n    # subinterpreter's threads to finish.  Instead, they will be stopped\n    # later by the mechanism we use for daemon threads.  The likelihood\n    # of this case is small because rarely will the _thread module be\n    # replaced by a module without _is_main_interpreter().\n    # Furthermore, this is all irrelevant in applications\n    # that do not use subinterpreters.\n    def _is_main_interpreter():\n        return True\ntry:\n    get_native_id = _thread.get_native_id\n    _HAVE_THREAD_NATIVE_ID = True\n    __all__.append('get_native_id')\nexcept AttributeError:\n    _HAVE_THREAD_NATIVE_ID = False\nThreadError = _thread.error\ntry:\n    _CRLock = _thread.RLock\nexcept AttributeError:\n    _CRLock = None\nTIMEOUT_MAX = _thread.TIMEOUT_MAX\ndel _thread\n\n\n# Support for profile and trace hooks\n\n_profile_hook = None\n_trace_hook = None\n\ndef setprofile(func):\n    \"\"\"Set a profile function for all threads started from the threading module.\n\n    The func will be passed to sys.setprofile() for each thread, before its\n    run() method is called.\n    \"\"\"\n    global _profile_hook\n    _profile_hook = func\n\ndef setprofile_all_threads(func):\n    \"\"\"Set a profile function for all threads started from the threading module\n    and all Python threads that are currently executing.\n\n    The func will be passed to sys.setprofile() for each thread, before its\n    run() method is called.\n    \"\"\"\n    setprofile(func)\n    _sys._setprofileallthreads(func)\n\ndef getprofile():\n    \"\"\"Get the profiler function as set by threading.setprofile().\"\"\"\n    return _profile_hook\n\ndef settrace(func):\n    \"\"\"Set a trace function for all threads started from the threading module.\n\n    The func will be passed to sys.settrace() for each thread, before its run()\n    method is called.\n    \"\"\"\n    global _trace_hook\n    _trace_hook = func\n\ndef settrace_all_threads(func):\n    \"\"\"Set a trace function for all threads started from the threading module\n    and all Python threads that are currently executing.\n\n    The func will be passed to sys.settrace() for each thread, before its run()\n    method is called.\n    \"\"\"\n    settrace(func)\n    _sys._settraceallthreads(func)\n\ndef gettrace():\n    \"\"\"Get the trace function as set by threading.settrace().\"\"\"\n    return _trace_hook\n\n# Synchronization classes\n\nLock = _allocate_lock\n\ndef RLock(*args, **kwargs):\n    \"\"\"Factory function that returns a new reentrant lock.\n\n    A reentrant lock must be released by the thread that acquired it. Once a\n    thread has acquired a reentrant lock, the same thread may acquire it again\n    without blocking; the thread must release it once for each time it has\n    acquired it.\n\n    \"\"\"\n    if _CRLock is None:\n        return _PyRLock(*args, **kwargs)\n    return _CRLock(*args, **kwargs)\n\nclass _RLock:\n    \"\"\"This class implements reentrant lock objects.\n\n    A reentrant lock must be released by the thread that acquired it. Once a\n    thread has acquired a reentrant lock, the same thread may acquire it\n    again without blocking; the thread must release it once for each time it\n    has acquired it.\n\n    \"\"\"\n\n    def __init__(self):\n        self._block = _allocate_lock()\n        self._owner = None\n        self._count = 0\n\n    def __repr__(self):\n        owner = self._owner\n        try:\n            owner = _active[owner].name\n        except KeyError:\n            pass\n        return \"<%s %s.%s object owner=%r count=%d at %s>\" % (\n            \"locked\" if self._block.locked() else \"unlocked\",\n            self.__class__.__module__,\n            self.__class__.__qualname__,\n            owner,\n            self._count,\n            hex(id(self))\n        )\n\n    def _at_fork_reinit(self):\n        self._block._at_fork_reinit()\n        self._owner = None\n        self._count = 0\n\n    def acquire(self, blocking=True, timeout=-1):\n        \"\"\"Acquire a lock, blocking or non-blocking.\n\n        When invoked without arguments: if this thread already owns the lock,\n        increment the recursion level by one, and return immediately. Otherwise,\n        if another thread owns the lock, block until the lock is unlocked. Once\n        the lock is unlocked (not owned by any thread), then grab ownership, set\n        the recursion level to one, and return. If more than one thread is\n        blocked waiting until the lock is unlocked, only one at a time will be\n        able to grab ownership of the lock. There is no return value in this\n        case.\n\n        When invoked with the blocking argument set to true, do the same thing\n        as when called without arguments, and return true.\n\n        When invoked with the blocking argument set to false, do not block. If a\n        call without an argument would block, return false immediately;\n        otherwise, do the same thing as when called without arguments, and\n        return true.\n\n        When invoked with the floating-point timeout argument set to a positive\n        value, block for at most the number of seconds specified by timeout\n        and as long as the lock cannot be acquired.  Return true if the lock has\n        been acquired, false if the timeout has elapsed.\n\n        \"\"\"\n        me = get_ident()\n        if self._owner == me:\n            self._count += 1\n            return 1\n        rc = self._block.acquire(blocking, timeout)\n        if rc:\n            self._owner = me\n            self._count = 1\n        return rc\n\n    __enter__ = acquire\n\n    def release(self):\n        \"\"\"Release a lock, decrementing the recursion level.\n\n        If after the decrement it is zero, reset the lock to unlocked (not owned\n        by any thread), and if any other threads are blocked waiting for the\n        lock to become unlocked, allow exactly one of them to proceed. If after\n        the decrement the recursion level is still nonzero, the lock remains\n        locked and owned by the calling thread.\n\n        Only call this method when the calling thread owns the lock. A\n        RuntimeError is raised if this method is called when the lock is\n        unlocked.\n\n        There is no return value.\n\n        \"\"\"\n        if self._owner != get_ident():\n            raise RuntimeError(\"cannot release un-acquired lock\")\n        self._count = count = self._count - 1\n        if not count:\n            self._owner = None\n            self._block.release()\n\n    def __exit__(self, t, v, tb):\n        self.release()\n\n    # Internal methods used by condition variables\n\n    def _acquire_restore(self, state):\n        self._block.acquire()\n        self._count, self._owner = state\n\n    def _release_save(self):\n        if self._count == 0:\n            raise RuntimeError(\"cannot release un-acquired lock\")\n        count = self._count\n        self._count = 0\n        owner = self._owner\n        self._owner = None\n        self._block.release()\n        return (count, owner)\n\n    def _is_owned(self):\n        return self._owner == get_ident()\n\n    # Internal method used for reentrancy checks\n\n    def _recursion_count(self):\n        if self._owner != get_ident():\n            return 0\n        return self._count\n\n_PyRLock = _RLock\n\n\nclass Condition:\n    \"\"\"Class that implements a condition variable.\n\n    A condition variable allows one or more threads to wait until they are\n    notified by another thread.\n\n    If the lock argument is given and not None, it must be a Lock or RLock\n    object, and it is used as the underlying lock. Otherwise, a new RLock object\n    is created and used as the underlying lock.\n\n    \"\"\"\n\n    def __init__(self, lock=None):\n        if lock is None:\n            lock = RLock()\n        self._lock = lock\n        # Export the lock's acquire() and release() methods\n        self.acquire = lock.acquire\n        self.release = lock.release\n        # If the lock defines _release_save() and/or _acquire_restore(),\n        # these override the default implementations (which just call\n        # release() and acquire() on the lock).  Ditto for _is_owned().\n        if hasattr(lock, '_release_save'):\n            self._release_save = lock._release_save\n        if hasattr(lock, '_acquire_restore'):\n            self._acquire_restore = lock._acquire_restore\n        if hasattr(lock, '_is_owned'):\n            self._is_owned = lock._is_owned\n        self._waiters = _deque()\n\n    def _at_fork_reinit(self):\n        self._lock._at_fork_reinit()\n        self._waiters.clear()\n\n    def __enter__(self):\n        return self._lock.__enter__()\n\n    def __exit__(self, *args):\n        return self._lock.__exit__(*args)\n\n    def __repr__(self):\n        return \"<Condition(%s, %d)>\" % (self._lock, len(self._waiters))\n\n    def _release_save(self):\n        self._lock.release()           # No state to save\n\n    def _acquire_restore(self, x):\n        self._lock.acquire()           # Ignore saved state\n\n    def _is_owned(self):\n        # Return True if lock is owned by current_thread.\n        # This method is called only if _lock doesn't have _is_owned().\n        if self._lock.acquire(False):\n            self._lock.release()\n            return False\n        else:\n            return True\n\n    def wait(self, timeout=None):\n        \"\"\"Wait until notified or until a timeout occurs.\n\n        If the calling thread has not acquired the lock when this method is\n        called, a RuntimeError is raised.\n\n        This method releases the underlying lock, and then blocks until it is\n        awakened by a notify() or notify_all() call for the same condition\n        variable in another thread, or until the optional timeout occurs. Once\n        awakened or timed out, it re-acquires the lock and returns.\n\n        When the timeout argument is present and not None, it should be a\n        floating-point number specifying a timeout for the operation in seconds\n        (or fractions thereof).\n\n        When the underlying lock is an RLock, it is not released using its\n        release() method, since this may not actually unlock the lock when it\n        was acquired multiple times recursively. Instead, an internal interface\n        of the RLock class is used, which really unlocks it even when it has\n        been recursively acquired several times. Another internal interface is\n        then used to restore the recursion level when the lock is reacquired.\n\n        \"\"\"\n        if not self._is_owned():\n            raise RuntimeError(\"cannot wait on un-acquired lock\")\n        waiter = _allocate_lock()\n        waiter.acquire()\n        self._waiters.append(waiter)\n        saved_state = self._release_save()\n        gotit = False\n        try:    # restore state no matter what (e.g., KeyboardInterrupt)\n            if timeout is None:\n                waiter.acquire()\n                gotit = True\n            else:\n                if timeout > 0:\n                    gotit = waiter.acquire(True, timeout)\n                else:\n                    gotit = waiter.acquire(False)\n            return gotit\n        finally:\n            self._acquire_restore(saved_state)\n            if not gotit:\n                try:\n                    self._waiters.remove(waiter)\n                except ValueError:\n                    pass\n\n    def wait_for(self, predicate, timeout=None):\n        \"\"\"Wait until a condition evaluates to True.\n\n        predicate should be a callable which result will be interpreted as a\n        boolean value.  A timeout may be provided giving the maximum time to\n        wait.\n\n        \"\"\"\n        endtime = None\n        waittime = timeout\n        result = predicate()\n        while not result:\n            if waittime is not None:\n                if endtime is None:\n                    endtime = _time() + waittime\n                else:\n                    waittime = endtime - _time()\n                    if waittime <= 0:\n                        break\n            self.wait(waittime)\n            result = predicate()\n        return result\n\n    def notify(self, n=1):\n        \"\"\"Wake up one or more threads waiting on this condition, if any.\n\n        If the calling thread has not acquired the lock when this method is\n        called, a RuntimeError is raised.\n\n        This method wakes up at most n of the threads waiting for the condition\n        variable; it is a no-op if no threads are waiting.\n\n        \"\"\"\n        if not self._is_owned():\n            raise RuntimeError(\"cannot notify on un-acquired lock\")\n        waiters = self._waiters\n        while waiters and n > 0:\n            waiter = waiters[0]\n            try:\n                waiter.release()\n            except RuntimeError:\n                # gh-92530: The previous call of notify() released the lock,\n                # but was interrupted before removing it from the queue.\n                # It can happen if a signal handler raises an exception,\n                # like CTRL+C which raises KeyboardInterrupt.\n                pass\n            else:\n                n -= 1\n            try:\n                waiters.remove(waiter)\n            except ValueError:\n                pass\n\n    def notify_all(self):\n        \"\"\"Wake up all threads waiting on this condition.\n\n        If the calling thread has not acquired the lock when this method\n        is called, a RuntimeError is raised.\n\n        \"\"\"\n        self.notify(len(self._waiters))\n\n    def notifyAll(self):\n        \"\"\"Wake up all threads waiting on this condition.\n\n        This method is deprecated, use notify_all() instead.\n\n        \"\"\"\n        import warnings\n        warnings.warn('notifyAll() is deprecated, use notify_all() instead',\n                      DeprecationWarning, stacklevel=2)\n        self.notify_all()\n\n\nclass Semaphore:\n    \"\"\"This class implements semaphore objects.\n\n    Semaphores manage a counter representing the number of release() calls minus\n    the number of acquire() calls, plus an initial value. The acquire() method\n    blocks if necessary until it can return without making the counter\n    negative. If not given, value defaults to 1.\n\n    \"\"\"\n\n    # After Tim Peters' semaphore class, but not quite the same (no maximum)\n\n    def __init__(self, value=1):\n        if value < 0:\n            raise ValueError(\"semaphore initial value must be >= 0\")\n        self._cond = Condition(Lock())\n        self._value = value\n\n    def __repr__(self):\n        cls = self.__class__\n        return (f\"<{cls.__module__}.{cls.__qualname__} at {id(self):#x}:\"\n                f\" value={self._value}>\")\n\n    def acquire(self, blocking=True, timeout=None):\n        \"\"\"Acquire a semaphore, decrementing the internal counter by one.\n\n        When invoked without arguments: if the internal counter is larger than\n        zero on entry, decrement it by one and return immediately. If it is zero\n        on entry, block, waiting until some other thread has called release() to\n        make it larger than zero. This is done with proper interlocking so that\n        if multiple acquire() calls are blocked, release() will wake exactly one\n        of them up. The implementation may pick one at random, so the order in\n        which blocked threads are awakened should not be relied on. There is no\n        return value in this case.\n\n        When invoked with blocking set to true, do the same thing as when called\n        without arguments, and return true.\n\n        When invoked with blocking set to false, do not block. If a call without\n        an argument would block, return false immediately; otherwise, do the\n        same thing as when called without arguments, and return true.\n\n        When invoked with a timeout other than None, it will block for at\n        most timeout seconds.  If acquire does not complete successfully in\n        that interval, return false.  Return true otherwise.\n\n        \"\"\"\n        if not blocking and timeout is not None:\n            raise ValueError(\"can't specify timeout for non-blocking acquire\")\n        rc = False\n        endtime = None\n        with self._cond:\n            while self._value == 0:\n                if not blocking:\n                    break\n                if timeout is not None:\n                    if endtime is None:\n                        endtime = _time() + timeout\n                    else:\n                        timeout = endtime - _time()\n                        if timeout <= 0:\n                            break\n                self._cond.wait(timeout)\n            else:\n                self._value -= 1\n                rc = True\n        return rc\n\n    __enter__ = acquire\n\n    def release(self, n=1):\n        \"\"\"Release a semaphore, incrementing the internal counter by one or more.\n\n        When the counter is zero on entry and another thread is waiting for it\n        to become larger than zero again, wake up that thread.\n\n        \"\"\"\n        if n < 1:\n            raise ValueError('n must be one or more')\n        with self._cond:\n            self._value += n\n            self._cond.notify(n)\n\n    def __exit__(self, t, v, tb):\n        self.release()\n\n\nclass BoundedSemaphore(Semaphore):\n    \"\"\"Implements a bounded semaphore.\n\n    A bounded semaphore checks to make sure its current value doesn't exceed its\n    initial value. If it does, ValueError is raised. In most situations\n    semaphores are used to guard resources with limited capacity.\n\n    If the semaphore is released too many times it's a sign of a bug. If not\n    given, value defaults to 1.\n\n    Like regular semaphores, bounded semaphores manage a counter representing\n    the number of release() calls minus the number of acquire() calls, plus an\n    initial value. The acquire() method blocks if necessary until it can return\n    without making the counter negative. If not given, value defaults to 1.\n\n    \"\"\"\n\n    def __init__(self, value=1):\n        super().__init__(value)\n        self._initial_value = value\n\n    def __repr__(self):\n        cls = self.__class__\n        return (f\"<{cls.__module__}.{cls.__qualname__} at {id(self):#x}:\"\n                f\" value={self._value}/{self._initial_value}>\")\n\n    def release(self, n=1):\n        \"\"\"Release a semaphore, incrementing the internal counter by one or more.\n\n        When the counter is zero on entry and another thread is waiting for it\n        to become larger than zero again, wake up that thread.\n\n        If the number of releases exceeds the number of acquires,\n        raise a ValueError.\n\n        \"\"\"\n        if n < 1:\n            raise ValueError('n must be one or more')\n        with self._cond:\n            if self._value + n > self._initial_value:\n                raise ValueError(\"Semaphore released too many times\")\n            self._value += n\n            self._cond.notify(n)\n\n\nclass Event:\n    \"\"\"Class implementing event objects.\n\n    Events manage a flag that can be set to true with the set() method and reset\n    to false with the clear() method. The wait() method blocks until the flag is\n    true.  The flag is initially false.\n\n    \"\"\"\n\n    # After Tim Peters' event class (without is_posted())\n\n    def __init__(self):\n        self._cond = Condition(Lock())\n        self._flag = False\n\n    def __repr__(self):\n        cls = self.__class__\n        status = 'set' if self._flag else 'unset'\n        return f\"<{cls.__module__}.{cls.__qualname__} at {id(self):#x}: {status}>\"\n\n    def _at_fork_reinit(self):\n        # Private method called by Thread._reset_internal_locks()\n        self._cond._at_fork_reinit()\n\n    def is_set(self):\n        \"\"\"Return true if and only if the internal flag is true.\"\"\"\n        return self._flag\n\n    def isSet(self):\n        \"\"\"Return true if and only if the internal flag is true.\n\n        This method is deprecated, use is_set() instead.\n\n        \"\"\"\n        import warnings\n        warnings.warn('isSet() is deprecated, use is_set() instead',\n                      DeprecationWarning, stacklevel=2)\n        return self.is_set()\n\n    def set(self):\n        \"\"\"Set the internal flag to true.\n\n        All threads waiting for it to become true are awakened. Threads\n        that call wait() once the flag is true will not block at all.\n\n        \"\"\"\n        with self._cond:\n            self._flag = True\n            self._cond.notify_all()\n\n    def clear(self):\n        \"\"\"Reset the internal flag to false.\n\n        Subsequently, threads calling wait() will block until set() is called to\n        set the internal flag to true again.\n\n        \"\"\"\n        with self._cond:\n            self._flag = False\n\n    def wait(self, timeout=None):\n        \"\"\"Block until the internal flag is true.\n\n        If the internal flag is true on entry, return immediately. Otherwise,\n        block until another thread calls set() to set the flag to true, or until\n        the optional timeout occurs.\n\n        When the timeout argument is present and not None, it should be a\n        floating-point number specifying a timeout for the operation in seconds\n        (or fractions thereof).\n\n        This method returns the internal flag on exit, so it will always return\n        True except if a timeout is given and the operation times out.\n\n        \"\"\"\n        with self._cond:\n            signaled = self._flag\n            if not signaled:\n                signaled = self._cond.wait(timeout)\n            return signaled\n\n\n# A barrier class.  Inspired in part by the pthread_barrier_* api and\n# the CyclicBarrier class from Java.  See\n# http://sourceware.org/pthreads-win32/manual/pthread_barrier_init.html and\n# http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/\n#        CyclicBarrier.html\n# for information.\n# We maintain two main states, 'filling' and 'draining' enabling the barrier\n# to be cyclic.  Threads are not allowed into it until it has fully drained\n# since the previous cycle.  In addition, a 'resetting' state exists which is\n# similar to 'draining' except that threads leave with a BrokenBarrierError,\n# and a 'broken' state in which all threads get the exception.\nclass Barrier:\n    \"\"\"Implements a Barrier.\n\n    Useful for synchronizing a fixed number of threads at known synchronization\n    points.  Threads block on 'wait()' and are simultaneously awoken once they\n    have all made that call.\n\n    \"\"\"\n\n    def __init__(self, parties, action=None, timeout=None):\n        \"\"\"Create a barrier, initialised to 'parties' threads.\n\n        'action' is a callable which, when supplied, will be called by one of\n        the threads after they have all entered the barrier and just prior to\n        releasing them all. If a 'timeout' is provided, it is used as the\n        default for all subsequent 'wait()' calls.\n\n        \"\"\"\n        if parties < 1:\n            raise ValueError(\"parties must be > 0\")\n        self._cond = Condition(Lock())\n        self._action = action\n        self._timeout = timeout\n        self._parties = parties\n        self._state = 0  # 0 filling, 1 draining, -1 resetting, -2 broken\n        self._count = 0\n\n    def __repr__(self):\n        cls = self.__class__\n        if self.broken:\n            return f\"<{cls.__module__}.{cls.__qualname__} at {id(self):#x}: broken>\"\n        return (f\"<{cls.__module__}.{cls.__qualname__} at {id(self):#x}:\"\n                f\" waiters={self.n_waiting}/{self.parties}>\")\n\n    def wait(self, timeout=None):\n        \"\"\"Wait for the barrier.\n\n        When the specified number of threads have started waiting, they are all\n        simultaneously awoken. If an 'action' was provided for the barrier, one\n        of the threads will have executed that callback prior to returning.\n        Returns an individual index number from 0 to 'parties-1'.\n\n        \"\"\"\n        if timeout is None:\n            timeout = self._timeout\n        with self._cond:\n            self._enter() # Block while the barrier drains.\n            index = self._count\n            self._count += 1\n            try:\n                if index + 1 == self._parties:\n                    # We release the barrier\n                    self._release()\n                else:\n                    # We wait until someone releases us\n                    self._wait(timeout)\n                return index\n            finally:\n                self._count -= 1\n                # Wake up any threads waiting for barrier to drain.\n                self._exit()\n\n    # Block until the barrier is ready for us, or raise an exception\n    # if it is broken.\n    def _enter(self):\n        while self._state in (-1, 1):\n            # It is draining or resetting, wait until done\n            self._cond.wait()\n        #see if the barrier is in a broken state\n        if self._state < 0:\n            raise BrokenBarrierError\n        assert self._state == 0\n\n    # Optionally run the 'action' and release the threads waiting\n    # in the barrier.\n    def _release(self):\n        try:\n            if self._action:\n                self._action()\n            # enter draining state\n            self._state = 1\n            self._cond.notify_all()\n        except:\n            #an exception during the _action handler.  Break and reraise\n            self._break()\n            raise\n\n    # Wait in the barrier until we are released.  Raise an exception\n    # if the barrier is reset or broken.\n    def _wait(self, timeout):\n        if not self._cond.wait_for(lambda : self._state != 0, timeout):\n            #timed out.  Break the barrier\n            self._break()\n            raise BrokenBarrierError\n        if self._state < 0:\n            raise BrokenBarrierError\n        assert self._state == 1\n\n    # If we are the last thread to exit the barrier, signal any threads\n    # waiting for the barrier to drain.\n    def _exit(self):\n        if self._count == 0:\n            if self._state in (-1, 1):\n                #resetting or draining\n                self._state = 0\n                self._cond.notify_all()\n\n    def reset(self):\n        \"\"\"Reset the barrier to the initial state.\n\n        Any threads currently waiting will get the BrokenBarrier exception\n        raised.\n\n        \"\"\"\n        with self._cond:\n            if self._count > 0:\n                if self._state == 0:\n                    #reset the barrier, waking up threads\n                    self._state = -1\n                elif self._state == -2:\n                    #was broken, set it to reset state\n                    #which clears when the last thread exits\n                    self._state = -1\n            else:\n                self._state = 0\n            self._cond.notify_all()\n\n    def abort(self):\n        \"\"\"Place the barrier into a 'broken' state.\n\n        Useful in case of error.  Any currently waiting threads and threads\n        attempting to 'wait()' will have BrokenBarrierError raised.\n\n        \"\"\"\n        with self._cond:\n            self._break()\n\n    def _break(self):\n        # An internal error was detected.  The barrier is set to\n        # a broken state all parties awakened.\n        self._state = -2\n        self._cond.notify_all()\n\n    @property\n    def parties(self):\n        \"\"\"Return the number of threads required to trip the barrier.\"\"\"\n        return self._parties\n\n    @property\n    def n_waiting(self):\n        \"\"\"Return the number of threads currently waiting at the barrier.\"\"\"\n        # We don't need synchronization here since this is an ephemeral result\n        # anyway.  It returns the correct value in the steady state.\n        if self._state == 0:\n            return self._count\n        return 0\n\n    @property\n    def broken(self):\n        \"\"\"Return True if the barrier is in a broken state.\"\"\"\n        return self._state == -2\n\n# exception raised by the Barrier class\nclass BrokenBarrierError(RuntimeError):\n    pass\n\n\n# Helper to generate new thread names\n_counter = _count(1).__next__\ndef _newname(name_template):\n    return name_template % _counter()\n\n# Active thread administration.\n#\n# bpo-44422: Use a reentrant lock to allow reentrant calls to functions like\n# threading.enumerate().\n_active_limbo_lock = RLock()\n_active = {}    # maps thread id to Thread object\n_limbo = {}\n_dangling = WeakSet()\n\n# Set of Thread._tstate_lock locks of non-daemon threads used by _shutdown()\n# to wait until all Python thread states get deleted:\n# see Thread._set_tstate_lock().\n_shutdown_locks_lock = _allocate_lock()\n_shutdown_locks = set()\n\ndef _maintain_shutdown_locks():\n    \"\"\"\n    Drop any shutdown locks that don't correspond to running threads anymore.\n\n    Calling this from time to time avoids an ever-growing _shutdown_locks\n    set when Thread objects are not joined explicitly. See bpo-37788.\n\n    This must be called with _shutdown_locks_lock acquired.\n    \"\"\"\n    # If a lock was released, the corresponding thread has exited\n    to_remove = [lock for lock in _shutdown_locks if not lock.locked()]\n    _shutdown_locks.difference_update(to_remove)\n\n\n# Main class for threads\n\nclass Thread:\n    \"\"\"A class that represents a thread of control.\n\n    This class can be safely subclassed in a limited fashion. There are two ways\n    to specify the activity: by passing a callable object to the constructor, or\n    by overriding the run() method in a subclass.\n\n    \"\"\"\n\n    _initialized = False\n\n    def __init__(self, group=None, target=None, name=None,\n                 args=(), kwargs=None, *, daemon=None):\n        \"\"\"This constructor should always be called with keyword arguments. Arguments are:\n\n        *group* should be None; reserved for future extension when a ThreadGroup\n        class is implemented.\n\n        *target* is the callable object to be invoked by the run()\n        method. Defaults to None, meaning nothing is called.\n\n        *name* is the thread name. By default, a unique name is constructed of\n        the form \"Thread-N\" where N is a small decimal number.\n\n        *args* is a list or tuple of arguments for the target invocation. Defaults to ().\n\n        *kwargs* is a dictionary of keyword arguments for the target\n        invocation. Defaults to {}.\n\n        If a subclass overrides the constructor, it must make sure to invoke\n        the base class constructor (Thread.__init__()) before doing anything\n        else to the thread.\n\n        \"\"\"\n        assert group is None, \"group argument must be None for now\"\n        if kwargs is None:\n            kwargs = {}\n        if name:\n            name = str(name)\n        else:\n            name = _newname(\"Thread-%d\")\n            if target is not None:\n                try:\n                    target_name = target.__name__\n                    name += f\" ({target_name})\"\n                except AttributeError:\n                    pass\n\n        self._target = target\n        self._name = name\n        self._args = args\n        self._kwargs = kwargs\n        if daemon is not None:\n            if daemon and not _daemon_threads_allowed():\n                raise RuntimeError('daemon threads are disabled in this (sub)interpreter')\n            self._daemonic = daemon\n        else:\n            self._daemonic = current_thread().daemon\n        self._ident = None\n        if _HAVE_THREAD_NATIVE_ID:\n            self._native_id = None\n        self._tstate_lock = None\n        self._started = Event()\n        self._is_stopped = False\n        self._initialized = True\n        # Copy of sys.stderr used by self._invoke_excepthook()\n        self._stderr = _sys.stderr\n        self._invoke_excepthook = _make_invoke_excepthook()\n        # For debugging and _after_fork()\n        _dangling.add(self)\n\n    def _reset_internal_locks(self, is_alive):\n        # private!  Called by _after_fork() to reset our internal locks as\n        # they may be in an invalid state leading to a deadlock or crash.\n        self._started._at_fork_reinit()\n        if is_alive:\n            # bpo-42350: If the fork happens when the thread is already stopped\n            # (ex: after threading._shutdown() has been called), _tstate_lock\n            # is None. Do nothing in this case.\n            if self._tstate_lock is not None:\n                self._tstate_lock._at_fork_reinit()\n                self._tstate_lock.acquire()\n        else:\n            # The thread isn't alive after fork: it doesn't have a tstate\n            # anymore.\n            self._is_stopped = True\n            self._tstate_lock = None\n\n    def __repr__(self):\n        assert self._initialized, \"Thread.__init__() was not called\"\n        status = \"initial\"\n        if self._started.is_set():\n            status = \"started\"\n        self.is_alive() # easy way to get ._is_stopped set when appropriate\n        if self._is_stopped:\n            status = \"stopped\"\n        if self._daemonic:\n            status += \" daemon\"\n        if self._ident is not None:\n            status += \" %s\" % self._ident\n        return \"<%s(%s, %s)>\" % (self.__class__.__name__, self._name, status)\n\n    def start(self):\n        \"\"\"Start the thread's activity.\n\n        It must be called at most once per thread object. It arranges for the\n        object's run() method to be invoked in a separate thread of control.\n\n        This method will raise a RuntimeError if called more than once on the\n        same thread object.\n\n        \"\"\"\n        if not self._initialized:\n            raise RuntimeError(\"thread.__init__() not called\")\n\n        if self._started.is_set():\n            raise RuntimeError(\"threads can only be started once\")\n\n        with _active_limbo_lock:\n            _limbo[self] = self\n        try:\n            _start_new_thread(self._bootstrap, ())\n        except Exception:\n            with _active_limbo_lock:\n                del _limbo[self]\n            raise\n        self._started.wait()\n\n    def run(self):\n        \"\"\"Method representing the thread's activity.\n\n        You may override this method in a subclass. The standard run() method\n        invokes the callable object passed to the object's constructor as the\n        target argument, if any, with sequential and keyword arguments taken\n        from the args and kwargs arguments, respectively.\n\n        \"\"\"\n        try:\n            if self._target is not None:\n                self._target(*self._args, **self._kwargs)\n        finally:\n            # Avoid a refcycle if the thread is running a function with\n            # an argument that has a member that points to the thread.\n            del self._target, self._args, self._kwargs\n\n    def _bootstrap(self):\n        # Wrapper around the real bootstrap code that ignores\n        # exceptions during interpreter cleanup.  Those typically\n        # happen when a daemon thread wakes up at an unfortunate\n        # moment, finds the world around it destroyed, and raises some\n        # random exception *** while trying to report the exception in\n        # _bootstrap_inner() below ***.  Those random exceptions\n        # don't help anybody, and they confuse users, so we suppress\n        # them.  We suppress them only when it appears that the world\n        # indeed has already been destroyed, so that exceptions in\n        # _bootstrap_inner() during normal business hours are properly\n        # reported.  Also, we only suppress them for daemonic threads;\n        # if a non-daemonic encounters this, something else is wrong.\n        try:\n            self._bootstrap_inner()\n        except:\n            if self._daemonic and _sys is None:\n                return\n            raise\n\n    def _set_ident(self):\n        self._ident = get_ident()\n\n    if _HAVE_THREAD_NATIVE_ID:\n        def _set_native_id(self):\n            self._native_id = get_native_id()\n\n    def _set_tstate_lock(self):\n        \"\"\"\n        Set a lock object which will be released by the interpreter when\n        the underlying thread state (see pystate.h) gets deleted.\n        \"\"\"\n        self._tstate_lock = _set_sentinel()\n        self._tstate_lock.acquire()\n\n        if not self.daemon:\n            with _shutdown_locks_lock:\n                _maintain_shutdown_locks()\n                _shutdown_locks.add(self._tstate_lock)\n\n    def _bootstrap_inner(self):\n        try:\n            self._set_ident()\n            self._set_tstate_lock()\n            if _HAVE_THREAD_NATIVE_ID:\n                self._set_native_id()\n            self._started.set()\n            with _active_limbo_lock:\n                _active[self._ident] = self\n                del _limbo[self]\n\n            if _trace_hook:\n                _sys.settrace(_trace_hook)\n            if _profile_hook:\n                _sys.setprofile(_profile_hook)\n\n            try:\n                self.run()\n            except:\n                self._invoke_excepthook(self)\n        finally:\n            self._delete()\n\n    def _stop(self):\n        # After calling ._stop(), .is_alive() returns False and .join() returns\n        # immediately.  ._tstate_lock must be released before calling ._stop().\n        #\n        # Normal case:  C code at the end of the thread's life\n        # (release_sentinel in _threadmodule.c) releases ._tstate_lock, and\n        # that's detected by our ._wait_for_tstate_lock(), called by .join()\n        # and .is_alive().  Any number of threads _may_ call ._stop()\n        # simultaneously (for example, if multiple threads are blocked in\n        # .join() calls), and they're not serialized.  That's harmless -\n        # they'll just make redundant rebindings of ._is_stopped and\n        # ._tstate_lock.  Obscure:  we rebind ._tstate_lock last so that the\n        # \"assert self._is_stopped\" in ._wait_for_tstate_lock() always works\n        # (the assert is executed only if ._tstate_lock is None).\n        #\n        # Special case:  _main_thread releases ._tstate_lock via this\n        # module's _shutdown() function.\n        lock = self._tstate_lock\n        if lock is not None:\n            assert not lock.locked()\n        self._is_stopped = True\n        self._tstate_lock = None\n        if not self.daemon:\n            with _shutdown_locks_lock:\n                # Remove our lock and other released locks from _shutdown_locks\n                _maintain_shutdown_locks()\n\n    def _delete(self):\n        \"Remove current thread from the dict of currently running threads.\"\n        with _active_limbo_lock:\n            del _active[get_ident()]\n            # There must not be any python code between the previous line\n            # and after the lock is released.  Otherwise a tracing function\n            # could try to acquire the lock again in the same thread, (in\n            # current_thread()), and would block.\n\n    def join(self, timeout=None):\n        \"\"\"Wait until the thread terminates.\n\n        This blocks the calling thread until the thread whose join() method is\n        called terminates -- either normally or through an unhandled exception\n        or until the optional timeout occurs.\n\n        When the timeout argument is present and not None, it should be a\n        floating-point number specifying a timeout for the operation in seconds\n        (or fractions thereof). As join() always returns None, you must call\n        is_alive() after join() to decide whether a timeout happened -- if the\n        thread is still alive, the join() call timed out.\n\n        When the timeout argument is not present or None, the operation will\n        block until the thread terminates.\n\n        A thread can be join()ed many times.\n\n        join() raises a RuntimeError if an attempt is made to join the current\n        thread as that would cause a deadlock. It is also an error to join() a\n        thread before it has been started and attempts to do so raises the same\n        exception.\n\n        \"\"\"\n        if not self._initialized:\n            raise RuntimeError(\"Thread.__init__() not called\")\n        if not self._started.is_set():\n            raise RuntimeError(\"cannot join thread before it is started\")\n        if self is current_thread():\n            raise RuntimeError(\"cannot join current thread\")\n\n        if timeout is None:\n            self._wait_for_tstate_lock()\n        else:\n            # the behavior of a negative timeout isn't documented, but\n            # historically .join(timeout=x) for x<0 has acted as if timeout=0\n            self._wait_for_tstate_lock(timeout=max(timeout, 0))\n\n    def _wait_for_tstate_lock(self, block=True, timeout=-1):\n        # Issue #18808: wait for the thread state to be gone.\n        # At the end of the thread's life, after all knowledge of the thread\n        # is removed from C data structures, C code releases our _tstate_lock.\n        # This method passes its arguments to _tstate_lock.acquire().\n        # If the lock is acquired, the C code is done, and self._stop() is\n        # called.  That sets ._is_stopped to True, and ._tstate_lock to None.\n        lock = self._tstate_lock\n        if lock is None:\n            # already determined that the C code is done\n            assert self._is_stopped\n            return\n\n        try:\n            if lock.acquire(block, timeout):\n                lock.release()\n                self._stop()\n        except:\n            if lock.locked():\n                # bpo-45274: lock.acquire() acquired the lock, but the function\n                # was interrupted with an exception before reaching the\n                # lock.release(). It can happen if a signal handler raises an\n                # exception, like CTRL+C which raises KeyboardInterrupt.\n                lock.release()\n                self._stop()\n            raise\n\n    @property\n    def name(self):\n        \"\"\"A string used for identification purposes only.\n\n        It has no semantics. Multiple threads may be given the same name. The\n        initial name is set by the constructor.\n\n        \"\"\"\n        assert self._initialized, \"Thread.__init__() not called\"\n        return self._name\n\n    @name.setter\n    def name(self, name):\n        assert self._initialized, \"Thread.__init__() not called\"\n        self._name = str(name)\n\n    @property\n    def ident(self):\n        \"\"\"Thread identifier of this thread or None if it has not been started.\n\n        This is a nonzero integer. See the get_ident() function. Thread\n        identifiers may be recycled when a thread exits and another thread is\n        created. The identifier is available even after the thread has exited.\n\n        \"\"\"\n        assert self._initialized, \"Thread.__init__() not called\"\n        return self._ident\n\n    if _HAVE_THREAD_NATIVE_ID:\n        @property\n        def native_id(self):\n            \"\"\"Native integral thread ID of this thread, or None if it has not been started.\n\n            This is a non-negative integer. See the get_native_id() function.\n            This represents the Thread ID as reported by the kernel.\n\n            \"\"\"\n            assert self._initialized, \"Thread.__init__() not called\"\n            return self._native_id\n\n    def is_alive(self):\n        \"\"\"Return whether the thread is alive.\n\n        This method returns True just before the run() method starts until just\n        after the run() method terminates. See also the module function\n        enumerate().\n\n        \"\"\"\n        assert self._initialized, \"Thread.__init__() not called\"\n        if self._is_stopped or not self._started.is_set():\n            return False\n        self._wait_for_tstate_lock(False)\n        return not self._is_stopped\n\n    @property\n    def daemon(self):\n        \"\"\"A boolean value indicating whether this thread is a daemon thread.\n\n        This must be set before start() is called, otherwise RuntimeError is\n        raised. Its initial value is inherited from the creating thread; the\n        main thread is not a daemon thread and therefore all threads created in\n        the main thread default to daemon = False.\n\n        The entire Python program exits when only daemon threads are left.\n\n        \"\"\"\n        assert self._initialized, \"Thread.__init__() not called\"\n        return self._daemonic\n\n    @daemon.setter\n    def daemon(self, daemonic):\n        if not self._initialized:\n            raise RuntimeError(\"Thread.__init__() not called\")\n        if daemonic and not _daemon_threads_allowed():\n            raise RuntimeError('daemon threads are disabled in this interpreter')\n        if self._started.is_set():\n            raise RuntimeError(\"cannot set daemon status of active thread\")\n        self._daemonic = daemonic\n\n    def isDaemon(self):\n        \"\"\"Return whether this thread is a daemon.\n\n        This method is deprecated, use the daemon attribute instead.\n\n        \"\"\"\n        import warnings\n        warnings.warn('isDaemon() is deprecated, get the daemon attribute instead',\n                      DeprecationWarning, stacklevel=2)\n        return self.daemon\n\n    def setDaemon(self, daemonic):\n        \"\"\"Set whether this thread is a daemon.\n\n        This method is deprecated, use the .daemon property instead.\n\n        \"\"\"\n        import warnings\n        warnings.warn('setDaemon() is deprecated, set the daemon attribute instead',\n                      DeprecationWarning, stacklevel=2)\n        self.daemon = daemonic\n\n    def getName(self):\n        \"\"\"Return a string used for identification purposes only.\n\n        This method is deprecated, use the name attribute instead.\n\n        \"\"\"\n        import warnings\n        warnings.warn('getName() is deprecated, get the name attribute instead',\n                      DeprecationWarning, stacklevel=2)\n        return self.name\n\n    def setName(self, name):\n        \"\"\"Set the name string for this thread.\n\n        This method is deprecated, use the name attribute instead.\n\n        \"\"\"\n        import warnings\n        warnings.warn('setName() is deprecated, set the name attribute instead',\n                      DeprecationWarning, stacklevel=2)\n        self.name = name\n\n\ntry:\n    from _thread import (_excepthook as excepthook,\n                         _ExceptHookArgs as ExceptHookArgs)\nexcept ImportError:\n    # Simple Python implementation if _thread._excepthook() is not available\n    from traceback import print_exception as _print_exception\n    from collections import namedtuple\n\n    _ExceptHookArgs = namedtuple(\n        'ExceptHookArgs',\n        'exc_type exc_value exc_traceback thread')\n\n    def ExceptHookArgs(args):\n        return _ExceptHookArgs(*args)\n\n    def excepthook(args, /):\n        \"\"\"\n        Handle uncaught Thread.run() exception.\n        \"\"\"\n        if args.exc_type == SystemExit:\n            # silently ignore SystemExit\n            return\n\n        if _sys is not None and _sys.stderr is not None:\n            stderr = _sys.stderr\n        elif args.thread is not None:\n            stderr = args.thread._stderr\n            if stderr is None:\n                # do nothing if sys.stderr is None and sys.stderr was None\n                # when the thread was created\n                return\n        else:\n            # do nothing if sys.stderr is None and args.thread is None\n            return\n\n        if args.thread is not None:\n            name = args.thread.name\n        else:\n            name = get_ident()\n        print(f\"Exception in thread {name}:\",\n              file=stderr, flush=True)\n        _print_exception(args.exc_type, args.exc_value, args.exc_traceback,\n                         file=stderr)\n        stderr.flush()\n\n\n# Original value of threading.excepthook\n__excepthook__ = excepthook\n\n\ndef _make_invoke_excepthook():\n    # Create a local namespace to ensure that variables remain alive\n    # when _invoke_excepthook() is called, even if it is called late during\n    # Python shutdown. It is mostly needed for daemon threads.\n\n    old_excepthook = excepthook\n    old_sys_excepthook = _sys.excepthook\n    if old_excepthook is None:\n        raise RuntimeError(\"threading.excepthook is None\")\n    if old_sys_excepthook is None:\n        raise RuntimeError(\"sys.excepthook is None\")\n\n    sys_exc_info = _sys.exc_info\n    local_print = print\n    local_sys = _sys\n\n    def invoke_excepthook(thread):\n        global excepthook\n        try:\n            hook = excepthook\n            if hook is None:\n                hook = old_excepthook\n\n            args = ExceptHookArgs([*sys_exc_info(), thread])\n\n            hook(args)\n        except Exception as exc:\n            exc.__suppress_context__ = True\n            del exc\n\n            if local_sys is not None and local_sys.stderr is not None:\n                stderr = local_sys.stderr\n            else:\n                stderr = thread._stderr\n\n            local_print(\"Exception in threading.excepthook:\",\n                        file=stderr, flush=True)\n\n            if local_sys is not None and local_sys.excepthook is not None:\n                sys_excepthook = local_sys.excepthook\n            else:\n                sys_excepthook = old_sys_excepthook\n\n            sys_excepthook(*sys_exc_info())\n        finally:\n            # Break reference cycle (exception stored in a variable)\n            args = None\n\n    return invoke_excepthook\n\n\n# The timer class was contributed by Itamar Shtull-Trauring\n\nclass Timer(Thread):\n    \"\"\"Call a function after a specified number of seconds:\n\n            t = Timer(30.0, f, args=None, kwargs=None)\n            t.start()\n            t.cancel()     # stop the timer's action if it's still waiting\n\n    \"\"\"\n\n    def __init__(self, interval, function, args=None, kwargs=None):\n        Thread.__init__(self)\n        self.interval = interval\n        self.function = function\n        self.args = args if args is not None else []\n        self.kwargs = kwargs if kwargs is not None else {}\n        self.finished = Event()\n\n    def cancel(self):\n        \"\"\"Stop the timer if it hasn't finished yet.\"\"\"\n        self.finished.set()\n\n    def run(self):\n        self.finished.wait(self.interval)\n        if not self.finished.is_set():\n            self.function(*self.args, **self.kwargs)\n        self.finished.set()\n\n\n# Special thread class to represent the main thread\n\nclass _MainThread(Thread):\n\n    def __init__(self):\n        Thread.__init__(self, name=\"MainThread\", daemon=False)\n        self._set_tstate_lock()\n        self._started.set()\n        self._set_ident()\n        if _HAVE_THREAD_NATIVE_ID:\n            self._set_native_id()\n        with _active_limbo_lock:\n            _active[self._ident] = self\n\n\n# Dummy thread class to represent threads not started here.\n# These aren't garbage collected when they die, nor can they be waited for.\n# If they invoke anything in threading.py that calls current_thread(), they\n# leave an entry in the _active dict forever after.\n# Their purpose is to return *something* from current_thread().\n# They are marked as daemon threads so we won't wait for them\n# when we exit (conform previous semantics).\n\nclass _DummyThread(Thread):\n\n    def __init__(self):\n        Thread.__init__(self, name=_newname(\"Dummy-%d\"),\n                        daemon=_daemon_threads_allowed())\n        self._started.set()\n        self._set_ident()\n        if _HAVE_THREAD_NATIVE_ID:\n            self._set_native_id()\n        with _active_limbo_lock:\n            _active[self._ident] = self\n\n    def _stop(self):\n        pass\n\n    def is_alive(self):\n        assert not self._is_stopped and self._started.is_set()\n        return True\n\n    def join(self, timeout=None):\n        assert False, \"cannot join a dummy thread\"\n\n\n# Global API functions\n\ndef current_thread():\n    \"\"\"Return the current Thread object, corresponding to the caller's thread of control.\n\n    If the caller's thread of control was not created through the threading\n    module, a dummy thread object with limited functionality is returned.\n\n    \"\"\"\n    try:\n        return _active[get_ident()]\n    except KeyError:\n        return _DummyThread()\n\ndef currentThread():\n    \"\"\"Return the current Thread object, corresponding to the caller's thread of control.\n\n    This function is deprecated, use current_thread() instead.\n\n    \"\"\"\n    import warnings\n    warnings.warn('currentThread() is deprecated, use current_thread() instead',\n                  DeprecationWarning, stacklevel=2)\n    return current_thread()\n\ndef active_count():\n    \"\"\"Return the number of Thread objects currently alive.\n\n    The returned count is equal to the length of the list returned by\n    enumerate().\n\n    \"\"\"\n    # NOTE: if the logic in here ever changes, update Modules/posixmodule.c\n    # warn_about_fork_with_threads() to match.\n    with _active_limbo_lock:\n        return len(_active) + len(_limbo)\n\ndef activeCount():\n    \"\"\"Return the number of Thread objects currently alive.\n\n    This function is deprecated, use active_count() instead.\n\n    \"\"\"\n    import warnings\n    warnings.warn('activeCount() is deprecated, use active_count() instead',\n                  DeprecationWarning, stacklevel=2)\n    return active_count()\n\ndef _enumerate():\n    # Same as enumerate(), but without the lock. Internal use only.\n    return list(_active.values()) + list(_limbo.values())\n\ndef enumerate():\n    \"\"\"Return a list of all Thread objects currently alive.\n\n    The list includes daemonic threads, dummy thread objects created by\n    current_thread(), and the main thread. It excludes terminated threads and\n    threads that have not yet been started.\n\n    \"\"\"\n    with _active_limbo_lock:\n        return list(_active.values()) + list(_limbo.values())\n\n\n_threading_atexits = []\n_SHUTTING_DOWN = False\n\ndef _register_atexit(func, *arg, **kwargs):\n    \"\"\"CPython internal: register *func* to be called before joining threads.\n\n    The registered *func* is called with its arguments just before all\n    non-daemon threads are joined in `_shutdown()`. It provides a similar\n    purpose to `atexit.register()`, but its functions are called prior to\n    threading shutdown instead of interpreter shutdown.\n\n    For similarity to atexit, the registered functions are called in reverse.\n    \"\"\"\n    if _SHUTTING_DOWN:\n        raise RuntimeError(\"can't register atexit after shutdown\")\n\n    call = functools.partial(func, *arg, **kwargs)\n    _threading_atexits.append(call)\n\n\nfrom _thread import stack_size\n\n# Create the main thread object,\n# and make it available for the interpreter\n# (Py_Main) as threading._shutdown.\n\n_main_thread = _MainThread()\n\ndef _shutdown():\n    \"\"\"\n    Wait until the Python thread state of all non-daemon threads get deleted.\n    \"\"\"\n    # Obscure:  other threads may be waiting to join _main_thread.  That's\n    # dubious, but some code does it.  We can't wait for C code to release\n    # the main thread's tstate_lock - that won't happen until the interpreter\n    # is nearly dead.  So we release it here.  Note that just calling _stop()\n    # isn't enough:  other threads may already be waiting on _tstate_lock.\n    if _main_thread._is_stopped and _is_main_interpreter():\n        # _shutdown() was already called\n        return\n\n    global _SHUTTING_DOWN\n    _SHUTTING_DOWN = True\n\n    # Call registered threading atexit functions before threads are joined.\n    # Order is reversed, similar to atexit.\n    for atexit_call in reversed(_threading_atexits):\n        atexit_call()\n\n    # Main thread\n    if _main_thread.ident == get_ident():\n        tlock = _main_thread._tstate_lock\n        # The main thread isn't finished yet, so its thread state lock can't\n        # have been released.\n        assert tlock is not None\n        assert tlock.locked()\n        tlock.release()\n        _main_thread._stop()\n    else:\n        # bpo-1596321: _shutdown() must be called in the main thread.\n        # If the threading module was not imported by the main thread,\n        # _main_thread is the thread which imported the threading module.\n        # In this case, ignore _main_thread, similar behavior than for threads\n        # spawned by C libraries or using _thread.start_new_thread().\n        pass\n\n    # Join all non-deamon threads\n    while True:\n        with _shutdown_locks_lock:\n            locks = list(_shutdown_locks)\n            _shutdown_locks.clear()\n\n        if not locks:\n            break\n\n        for lock in locks:\n            # mimic Thread.join()\n            lock.acquire()\n            lock.release()\n\n        # new threads can be spawned while we were waiting for the other\n        # threads to complete\n\n\ndef main_thread():\n    \"\"\"Return the main thread object.\n\n    In normal conditions, the main thread is the thread from which the\n    Python interpreter was started.\n    \"\"\"\n    # XXX Figure this out for subinterpreters.  (See gh-75698.)\n    return _main_thread\n\n# get thread-local implementation, either from the thread\n# module, or from the python fallback\n\ntry:\n    from _thread import _local as local\nexcept ImportError:\n    from _threading_local import local\n\n\ndef _after_fork():\n    \"\"\"\n    Cleanup threading module state that should not exist after a fork.\n    \"\"\"\n    # Reset _active_limbo_lock, in case we forked while the lock was held\n    # by another (non-forked) thread.  http://bugs.python.org/issue874900\n    global _active_limbo_lock, _main_thread\n    global _shutdown_locks_lock, _shutdown_locks\n    _active_limbo_lock = RLock()\n\n    # fork() only copied the current thread; clear references to others.\n    new_active = {}\n\n    try:\n        current = _active[get_ident()]\n    except KeyError:\n        # fork() was called in a thread which was not spawned\n        # by threading.Thread. For example, a thread spawned\n        # by thread.start_new_thread().\n        current = _MainThread()\n\n    _main_thread = current\n\n    # reset _shutdown() locks: threads re-register their _tstate_lock below\n    _shutdown_locks_lock = _allocate_lock()\n    _shutdown_locks = set()\n\n    with _active_limbo_lock:\n        # Dangling thread instances must still have their locks reset,\n        # because someone may join() them.\n        threads = set(_enumerate())\n        threads.update(_dangling)\n        for thread in threads:\n            # Any lock/condition variable may be currently locked or in an\n            # invalid state, so we reinitialize them.\n            if thread is current:\n                # There is only one active thread. We reset the ident to\n                # its new value since it can have changed.\n                thread._reset_internal_locks(True)\n                ident = get_ident()\n                if isinstance(thread, _DummyThread):\n                    thread.__class__ = _MainThread\n                    thread._name = 'MainThread'\n                    thread._daemonic = False\n                    thread._set_tstate_lock()\n                thread._ident = ident\n                new_active[ident] = thread\n            else:\n                # All the others are already stopped.\n                thread._reset_internal_locks(False)\n                thread._stop()\n\n        _limbo.clear()\n        _active.clear()\n        _active.update(new_active)\n        assert len(_active) == 1\n\n\nif hasattr(_os, \"register_at_fork\"):\n    _os.register_at_fork(after_in_child=_after_fork)\n", 1708], "/opt/anaconda3/lib/python3.12/enum.py": ["import sys\nimport builtins as bltns\nfrom types import MappingProxyType, DynamicClassAttribute\nfrom operator import or_ as _or_\nfrom functools import reduce\n\n\n__all__ = [\n        'EnumType', 'EnumMeta',\n        'Enum', 'IntEnum', 'StrEnum', 'Flag', 'IntFlag', 'ReprEnum',\n        'auto', 'unique', 'property', 'verify', 'member', 'nonmember',\n        'FlagBoundary', 'STRICT', 'CONFORM', 'EJECT', 'KEEP',\n        'global_flag_repr', 'global_enum_repr', 'global_str', 'global_enum',\n        'EnumCheck', 'CONTINUOUS', 'NAMED_FLAGS', 'UNIQUE',\n        'pickle_by_global_name', 'pickle_by_enum_name',\n        ]\n\n\n# Dummy value for Enum and Flag as there are explicit checks for them\n# before they have been created.\n# This is also why there are checks in EnumType like `if Enum is not None`\nEnum = Flag = EJECT = _stdlib_enums = ReprEnum = None\n\nclass nonmember(object):\n    \"\"\"\n    Protects item from becoming an Enum member during class creation.\n    \"\"\"\n    def __init__(self, value):\n        self.value = value\n\nclass member(object):\n    \"\"\"\n    Forces item to become an Enum member during class creation.\n    \"\"\"\n    def __init__(self, value):\n        self.value = value\n\ndef _is_descriptor(obj):\n    \"\"\"\n    Returns True if obj is a descriptor, False otherwise.\n    \"\"\"\n    return (\n            hasattr(obj, '__get__') or\n            hasattr(obj, '__set__') or\n            hasattr(obj, '__delete__')\n            )\n\ndef _is_dunder(name):\n    \"\"\"\n    Returns True if a __dunder__ name, False otherwise.\n    \"\"\"\n    return (\n            len(name) > 4 and\n            name[:2] == name[-2:] == '__' and\n            name[2] != '_' and\n            name[-3] != '_'\n            )\n\ndef _is_sunder(name):\n    \"\"\"\n    Returns True if a _sunder_ name, False otherwise.\n    \"\"\"\n    return (\n            len(name) > 2 and\n            name[0] == name[-1] == '_' and\n            name[1:2] != '_' and\n            name[-2:-1] != '_'\n            )\n\ndef _is_internal_class(cls_name, obj):\n    # do not use `re` as `re` imports `enum`\n    if not isinstance(obj, type):\n        return False\n    qualname = getattr(obj, '__qualname__', '')\n    s_pattern = cls_name + '.' + getattr(obj, '__name__', '')\n    e_pattern = '.' + s_pattern\n    return qualname == s_pattern or qualname.endswith(e_pattern)\n\ndef _is_private(cls_name, name):\n    # do not use `re` as `re` imports `enum`\n    pattern = '_%s__' % (cls_name, )\n    pat_len = len(pattern)\n    if (\n            len(name) > pat_len\n            and name.startswith(pattern)\n            and name[pat_len:pat_len+1] != ['_']\n            and (name[-1] != '_' or name[-2] != '_')\n        ):\n        return True\n    else:\n        return False\n\ndef _is_single_bit(num):\n    \"\"\"\n    True if only one bit set in num (should be an int)\n    \"\"\"\n    if num == 0:\n        return False\n    num &= num - 1\n    return num == 0\n\ndef _make_class_unpicklable(obj):\n    \"\"\"\n    Make the given obj un-picklable.\n\n    obj should be either a dictionary, or an Enum\n    \"\"\"\n    def _break_on_call_reduce(self, proto):\n        raise TypeError('%r cannot be pickled' % self)\n    if isinstance(obj, dict):\n        obj['__reduce_ex__'] = _break_on_call_reduce\n        obj['__module__'] = '<unknown>'\n    else:\n        setattr(obj, '__reduce_ex__', _break_on_call_reduce)\n        setattr(obj, '__module__', '<unknown>')\n\ndef _iter_bits_lsb(num):\n    # num must be a positive integer\n    original = num\n    if isinstance(num, Enum):\n        num = num.value\n    if num < 0:\n        raise ValueError('%r is not a positive integer' % original)\n    while num:\n        b = num & (~num + 1)\n        yield b\n        num ^= b\n\ndef show_flag_values(value):\n    return list(_iter_bits_lsb(value))\n\ndef bin(num, max_bits=None):\n    \"\"\"\n    Like built-in bin(), except negative values are represented in\n    twos-compliment, and the leading bit always indicates sign\n    (0=positive, 1=negative).\n\n    >>> bin(10)\n    '0b0 1010'\n    >>> bin(~10)   # ~10 is -11\n    '0b1 0101'\n    \"\"\"\n\n    ceiling = 2 ** (num).bit_length()\n    if num >= 0:\n        s = bltns.bin(num + ceiling).replace('1', '0', 1)\n    else:\n        s = bltns.bin(~num ^ (ceiling - 1) + ceiling)\n    sign = s[:3]\n    digits = s[3:]\n    if max_bits is not None:\n        if len(digits) < max_bits:\n            digits = (sign[-1] * max_bits + digits)[-max_bits:]\n    return \"%s %s\" % (sign, digits)\n\ndef _dedent(text):\n    \"\"\"\n    Like textwrap.dedent.  Rewritten because we cannot import textwrap.\n    \"\"\"\n    lines = text.split('\\n')\n    blanks = 0\n    for i, ch in enumerate(lines[0]):\n        if ch != ' ':\n            break\n    for j, l in enumerate(lines):\n        lines[j] = l[i:]\n    return '\\n'.join(lines)\n\nclass _not_given:\n    def __repr__(self):\n        return('<not given>')\n_not_given = _not_given()\n\nclass _auto_null:\n    def __repr__(self):\n        return '_auto_null'\n_auto_null = _auto_null()\n\nclass auto:\n    \"\"\"\n    Instances are replaced with an appropriate value in Enum class suites.\n    \"\"\"\n    def __init__(self, value=_auto_null):\n        self.value = value\n\n    def __repr__(self):\n        return \"auto(%r)\" % self.value\n\nclass property(DynamicClassAttribute):\n    \"\"\"\n    This is a descriptor, used to define attributes that act differently\n    when accessed through an enum member and through an enum class.\n    Instance access is the same as property(), but access to an attribute\n    through the enum class will instead look in the class' _member_map_ for\n    a corresponding enum member.\n    \"\"\"\n\n    member = None\n    _attr_type = None\n    _cls_type = None\n\n    def __get__(self, instance, ownerclass=None):\n        if instance is None:\n            if self.member is not None:\n                return self.member\n            else:\n                raise AttributeError(\n                        '%r has no attribute %r' % (ownerclass, self.name)\n                        )\n        if self.fget is not None:\n            # use previous enum.property\n            return self.fget(instance)\n        elif self._attr_type == 'attr':\n            # look up previous attibute\n            return getattr(self._cls_type, self.name)\n        elif self._attr_type == 'desc':\n            # use previous descriptor\n            return getattr(instance._value_, self.name)\n        # look for a member by this name.\n        try:\n            return ownerclass._member_map_[self.name]\n        except KeyError:\n            raise AttributeError(\n                    '%r has no attribute %r' % (ownerclass, self.name)\n                    ) from None\n\n    def __set__(self, instance, value):\n        if self.fset is not None:\n            return self.fset(instance, value)\n        raise AttributeError(\n                \"<enum %r> cannot set attribute %r\" % (self.clsname, self.name)\n                )\n\n    def __delete__(self, instance):\n        if self.fdel is not None:\n            return self.fdel(instance)\n        raise AttributeError(\n                \"<enum %r> cannot delete attribute %r\" % (self.clsname, self.name)\n                )\n\n    def __set_name__(self, ownerclass, name):\n        self.name = name\n        self.clsname = ownerclass.__name__\n\n\nclass _proto_member:\n    \"\"\"\n    intermediate step for enum members between class execution and final creation\n    \"\"\"\n\n    def __init__(self, value):\n        self.value = value\n\n    def __set_name__(self, enum_class, member_name):\n        \"\"\"\n        convert each quasi-member into an instance of the new enum class\n        \"\"\"\n        # first step: remove ourself from enum_class\n        delattr(enum_class, member_name)\n        # second step: create member based on enum_class\n        value = self.value\n        if not isinstance(value, tuple):\n            args = (value, )\n        else:\n            args = value\n        if enum_class._member_type_ is tuple:   # special case for tuple enums\n            args = (args, )     # wrap it one more time\n        if not enum_class._use_args_:\n            enum_member = enum_class._new_member_(enum_class)\n        else:\n            enum_member = enum_class._new_member_(enum_class, *args)\n        if not hasattr(enum_member, '_value_'):\n            if enum_class._member_type_ is object:\n                enum_member._value_ = value\n            else:\n                try:\n                    enum_member._value_ = enum_class._member_type_(*args)\n                except Exception as exc:\n                    new_exc = TypeError(\n                            '_value_ not set in __new__, unable to create it'\n                            )\n                    new_exc.__cause__ = exc\n                    raise new_exc\n        value = enum_member._value_\n        enum_member._name_ = member_name\n        enum_member.__objclass__ = enum_class\n        enum_member.__init__(*args)\n        enum_member._sort_order_ = len(enum_class._member_names_)\n\n        if Flag is not None and issubclass(enum_class, Flag):\n            if isinstance(value, int):\n                enum_class._flag_mask_ |= value\n                if _is_single_bit(value):\n                    enum_class._singles_mask_ |= value\n            enum_class._all_bits_ = 2 ** ((enum_class._flag_mask_).bit_length()) - 1\n\n        # If another member with the same value was already defined, the\n        # new member becomes an alias to the existing one.\n        try:\n            try:\n                # try to do a fast lookup to avoid the quadratic loop\n                enum_member = enum_class._value2member_map_[value]\n            except TypeError:\n                for name, canonical_member in enum_class._member_map_.items():\n                    if canonical_member._value_ == value:\n                        enum_member = canonical_member\n                        break\n                else:\n                    raise KeyError\n        except KeyError:\n            # this could still be an alias if the value is multi-bit and the\n            # class is a flag class\n            if (\n                    Flag is None\n                    or not issubclass(enum_class, Flag)\n                ):\n                # no other instances found, record this member in _member_names_\n                enum_class._member_names_.append(member_name)\n            elif (\n                    Flag is not None\n                    and issubclass(enum_class, Flag)\n                    and isinstance(value, int)\n                    and _is_single_bit(value)\n                ):\n                # no other instances found, record this member in _member_names_\n                enum_class._member_names_.append(member_name)\n        # if necessary, get redirect in place and then add it to _member_map_\n        found_descriptor = None\n        descriptor_type = None\n        class_type = None\n        for base in enum_class.__mro__[1:]:\n            attr = base.__dict__.get(member_name)\n            if attr is not None:\n                if isinstance(attr, (property, DynamicClassAttribute)):\n                    found_descriptor = attr\n                    class_type = base\n                    descriptor_type = 'enum'\n                    break\n                elif _is_descriptor(attr):\n                    found_descriptor = attr\n                    descriptor_type = descriptor_type or 'desc'\n                    class_type = class_type or base\n                    continue\n                else:\n                    descriptor_type = 'attr'\n                    class_type = base\n        if found_descriptor:\n            redirect = property()\n            redirect.member = enum_member\n            redirect.__set_name__(enum_class, member_name)\n            if descriptor_type in ('enum','desc'):\n                # earlier descriptor found; copy fget, fset, fdel to this one.\n                redirect.fget = getattr(found_descriptor, 'fget', None)\n                redirect._get = getattr(found_descriptor, '__get__', None)\n                redirect.fset = getattr(found_descriptor, 'fset', None)\n                redirect._set = getattr(found_descriptor, '__set__', None)\n                redirect.fdel = getattr(found_descriptor, 'fdel', None)\n                redirect._del = getattr(found_descriptor, '__delete__', None)\n            redirect._attr_type = descriptor_type\n            redirect._cls_type = class_type\n            setattr(enum_class, member_name, redirect)\n        else:\n            setattr(enum_class, member_name, enum_member)\n        # now add to _member_map_ (even aliases)\n        enum_class._member_map_[member_name] = enum_member\n        try:\n            # This may fail if value is not hashable. We can't add the value\n            # to the map, and by-value lookups for this value will be\n            # linear.\n            enum_class._value2member_map_.setdefault(value, enum_member)\n        except TypeError:\n            # keep track of the value in a list so containment checks are quick\n            enum_class._unhashable_values_.append(value)\n\n\nclass _EnumDict(dict):\n    \"\"\"\n    Track enum member order and ensure member names are not reused.\n\n    EnumType will use the names found in self._member_names as the\n    enumeration member names.\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        self._member_names = {} # use a dict to keep insertion order\n        self._last_values = []\n        self._ignore = []\n        self._auto_called = False\n\n    def __setitem__(self, key, value):\n        \"\"\"\n        Changes anything not dundered or not a descriptor.\n\n        If an enum member name is used twice, an error is raised; duplicate\n        values are not checked for.\n\n        Single underscore (sunder) names are reserved.\n        \"\"\"\n        if _is_internal_class(self._cls_name, value):\n            import warnings\n            warnings.warn(\n                    \"In 3.13 classes created inside an enum will not become a member.  \"\n                    \"Use the `member` decorator to keep the current behavior.\",\n                    DeprecationWarning,\n                    stacklevel=2,\n                    )\n        if _is_private(self._cls_name, key):\n            # also do nothing, name will be a normal attribute\n            pass\n        elif _is_sunder(key):\n            if key not in (\n                    '_order_',\n                    '_generate_next_value_', '_numeric_repr_', '_missing_', '_ignore_',\n                    '_iter_member_', '_iter_member_by_value_', '_iter_member_by_def_',\n                    ):\n                raise ValueError(\n                        '_sunder_ names, such as %r, are reserved for future Enum use'\n                        % (key, )\n                        )\n            if key == '_generate_next_value_':\n                # check if members already defined as auto()\n                if self._auto_called:\n                    raise TypeError(\"_generate_next_value_ must be defined before members\")\n                _gnv = value.__func__ if isinstance(value, staticmethod) else value\n                setattr(self, '_generate_next_value', _gnv)\n            elif key == '_ignore_':\n                if isinstance(value, str):\n                    value = value.replace(',',' ').split()\n                else:\n                    value = list(value)\n                self._ignore = value\n                already = set(value) & set(self._member_names)\n                if already:\n                    raise ValueError(\n                            '_ignore_ cannot specify already set names: %r'\n                            % (already, )\n                            )\n        elif _is_dunder(key):\n            if key == '__order__':\n                key = '_order_'\n        elif key in self._member_names:\n            # descriptor overwriting an enum?\n            raise TypeError('%r already defined as %r' % (key, self[key]))\n        elif key in self._ignore:\n            pass\n        elif isinstance(value, nonmember):\n            # unwrap value here; it won't be processed by the below `else`\n            value = value.value\n        elif _is_descriptor(value):\n            pass\n        # TODO: uncomment next three lines in 3.13\n        # elif _is_internal_class(self._cls_name, value):\n        #     # do nothing, name will be a normal attribute\n        #     pass\n        else:\n            if key in self:\n                # enum overwriting a descriptor?\n                raise TypeError('%r already defined as %r' % (key, self[key]))\n            elif isinstance(value, member):\n                # unwrap value here -- it will become a member\n                value = value.value\n            non_auto_store = True\n            single = False\n            if isinstance(value, auto):\n                single = True\n                value = (value, )\n            if isinstance(value, tuple) and any(isinstance(v, auto) for v in value):\n                # insist on an actual tuple, no subclasses, in keeping with only supporting\n                # top-level auto() usage (not contained in any other data structure)\n                auto_valued = []\n                t = type(value)\n                for v in value:\n                    if isinstance(v, auto):\n                        non_auto_store = False\n                        if v.value == _auto_null:\n                            v.value = self._generate_next_value(\n                                    key, 1, len(self._member_names), self._last_values[:],\n                                    )\n                            self._auto_called = True\n                        v = v.value\n                        self._last_values.append(v)\n                    auto_valued.append(v)\n                if single:\n                    value = auto_valued[0]\n                else:\n                    try:\n                        # accepts iterable as multiple arguments?\n                        value = t(auto_valued)\n                    except TypeError:\n                        # then pass them in singly\n                        value = t(*auto_valued)\n            self._member_names[key] = None\n            if non_auto_store:\n                self._last_values.append(value)\n        super().__setitem__(key, value)\n\n    def update(self, members, **more_members):\n        try:\n            for name in members.keys():\n                self[name] = members[name]\n        except AttributeError:\n            for name, value in members:\n                self[name] = value\n        for name, value in more_members.items():\n            self[name] = value\n\n\nclass EnumType(type):\n    \"\"\"\n    Metaclass for Enum\n    \"\"\"\n\n    @classmethod\n    def __prepare__(metacls, cls, bases, **kwds):\n        # check that previous enum members do not exist\n        metacls._check_for_existing_members_(cls, bases)\n        # create the namespace dict\n        enum_dict = _EnumDict()\n        enum_dict._cls_name = cls\n        # inherit previous flags and _generate_next_value_ function\n        member_type, first_enum = metacls._get_mixins_(cls, bases)\n        if first_enum is not None:\n            enum_dict['_generate_next_value_'] = getattr(\n                    first_enum, '_generate_next_value_', None,\n                    )\n        return enum_dict\n\n    def __new__(metacls, cls, bases, classdict, *, boundary=None, _simple=False, **kwds):\n        # an Enum class is final once enumeration items have been defined; it\n        # cannot be mixed with other types (int, float, etc.) if it has an\n        # inherited __new__ unless a new __new__ is defined (or the resulting\n        # class will fail).\n        #\n        if _simple:\n            return super().__new__(metacls, cls, bases, classdict, **kwds)\n        #\n        # remove any keys listed in _ignore_\n        classdict.setdefault('_ignore_', []).append('_ignore_')\n        ignore = classdict['_ignore_']\n        for key in ignore:\n            classdict.pop(key, None)\n        #\n        # grab member names\n        member_names = classdict._member_names\n        #\n        # check for illegal enum names (any others?)\n        invalid_names = set(member_names) & {'mro', ''}\n        if invalid_names:\n            raise ValueError('invalid enum member name(s) %s'  % (\n                    ','.join(repr(n) for n in invalid_names)\n                    ))\n        #\n        # adjust the sunders\n        _order_ = classdict.pop('_order_', None)\n        _gnv = classdict.get('_generate_next_value_')\n        if _gnv is not None and type(_gnv) is not staticmethod:\n            _gnv = staticmethod(_gnv)\n        # convert to normal dict\n        classdict = dict(classdict.items())\n        if _gnv is not None:\n            classdict['_generate_next_value_'] = _gnv\n        #\n        # data type of member and the controlling Enum class\n        member_type, first_enum = metacls._get_mixins_(cls, bases)\n        __new__, save_new, use_args = metacls._find_new_(\n                classdict, member_type, first_enum,\n                )\n        classdict['_new_member_'] = __new__\n        classdict['_use_args_'] = use_args\n        #\n        # convert future enum members into temporary _proto_members\n        for name in member_names:\n            value = classdict[name]\n            classdict[name] = _proto_member(value)\n        #\n        # house-keeping structures\n        classdict['_member_names_'] = []\n        classdict['_member_map_'] = {}\n        classdict['_value2member_map_'] = {}\n        classdict['_unhashable_values_'] = []\n        classdict['_member_type_'] = member_type\n        # now set the __repr__ for the value\n        classdict['_value_repr_'] = metacls._find_data_repr_(cls, bases)\n        #\n        # Flag structures (will be removed if final class is not a Flag\n        classdict['_boundary_'] = (\n                boundary\n                or getattr(first_enum, '_boundary_', None)\n                )\n        classdict['_flag_mask_'] = 0\n        classdict['_singles_mask_'] = 0\n        classdict['_all_bits_'] = 0\n        classdict['_inverted_'] = None\n        try:\n            exc = None\n            enum_class = super().__new__(metacls, cls, bases, classdict, **kwds)\n        except Exception as e:\n            # since 3.12 the line \"Error calling __set_name__ on '_proto_member' instance ...\"\n            # is tacked on to the error instead of raising a RuntimeError\n            # recreate the exception to discard\n            exc = type(e)(str(e))\n            exc.__cause__ = e.__cause__\n            exc.__context__ = e.__context__\n            tb = e.__traceback__\n        if exc is not None:\n            raise exc.with_traceback(tb)\n        #\n        # update classdict with any changes made by __init_subclass__\n        classdict.update(enum_class.__dict__)\n        #\n        # double check that repr and friends are not the mixin's or various\n        # things break (such as pickle)\n        # however, if the method is defined in the Enum itself, don't replace\n        # it\n        #\n        # Also, special handling for ReprEnum\n        if ReprEnum is not None and ReprEnum in bases:\n            if member_type is object:\n                raise TypeError(\n                        'ReprEnum subclasses must be mixed with a data type (i.e.'\n                        ' int, str, float, etc.)'\n                        )\n            if '__format__' not in classdict:\n                enum_class.__format__ = member_type.__format__\n                classdict['__format__'] = enum_class.__format__\n            if '__str__' not in classdict:\n                method = member_type.__str__\n                if method is object.__str__:\n                    # if member_type does not define __str__, object.__str__ will use\n                    # its __repr__ instead, so we'll also use its __repr__\n                    method = member_type.__repr__\n                enum_class.__str__ = method\n                classdict['__str__'] = enum_class.__str__\n        for name in ('__repr__', '__str__', '__format__', '__reduce_ex__'):\n            if name not in classdict:\n                # check for mixin overrides before replacing\n                enum_method = getattr(first_enum, name)\n                found_method = getattr(enum_class, name)\n                object_method = getattr(object, name)\n                data_type_method = getattr(member_type, name)\n                if found_method in (data_type_method, object_method):\n                    setattr(enum_class, name, enum_method)\n        #\n        # for Flag, add __or__, __and__, __xor__, and __invert__\n        if Flag is not None and issubclass(enum_class, Flag):\n            for name in (\n                    '__or__', '__and__', '__xor__',\n                    '__ror__', '__rand__', '__rxor__',\n                    '__invert__'\n                ):\n                if name not in classdict:\n                    enum_method = getattr(Flag, name)\n                    setattr(enum_class, name, enum_method)\n                    classdict[name] = enum_method\n        #\n        # replace any other __new__ with our own (as long as Enum is not None,\n        # anyway) -- again, this is to support pickle\n        if Enum is not None:\n            # if the user defined their own __new__, save it before it gets\n            # clobbered in case they subclass later\n            if save_new:\n                enum_class.__new_member__ = __new__\n            enum_class.__new__ = Enum.__new__\n        #\n        # py3 support for definition order (helps keep py2/py3 code in sync)\n        #\n        # _order_ checking is spread out into three/four steps\n        # - if enum_class is a Flag:\n        #   - remove any non-single-bit flags from _order_\n        # - remove any aliases from _order_\n        # - check that _order_ and _member_names_ match\n        #\n        # step 1: ensure we have a list\n        if _order_ is not None:\n            if isinstance(_order_, str):\n                _order_ = _order_.replace(',', ' ').split()\n        #\n        # remove Flag structures if final class is not a Flag\n        if (\n                Flag is None and cls != 'Flag'\n                or Flag is not None and not issubclass(enum_class, Flag)\n            ):\n            delattr(enum_class, '_boundary_')\n            delattr(enum_class, '_flag_mask_')\n            delattr(enum_class, '_singles_mask_')\n            delattr(enum_class, '_all_bits_')\n            delattr(enum_class, '_inverted_')\n        elif Flag is not None and issubclass(enum_class, Flag):\n            # set correct __iter__\n            member_list = [m._value_ for m in enum_class]\n            if member_list != sorted(member_list):\n                enum_class._iter_member_ = enum_class._iter_member_by_def_\n            if _order_:\n                # _order_ step 2: remove any items from _order_ that are not single-bit\n                _order_ = [\n                        o\n                        for o in _order_\n                        if o not in enum_class._member_map_ or _is_single_bit(enum_class[o]._value_)\n                        ]\n        #\n        if _order_:\n            # _order_ step 3: remove aliases from _order_\n            _order_ = [\n                    o\n                    for o in _order_\n                    if (\n                        o not in enum_class._member_map_\n                        or\n                        (o in enum_class._member_map_ and o in enum_class._member_names_)\n                        )]\n            # _order_ step 4: verify that _order_ and _member_names_ match\n            if _order_ != enum_class._member_names_:\n                raise TypeError(\n                        'member order does not match _order_:\\n  %r\\n  %r'\n                        % (enum_class._member_names_, _order_)\n                        )\n        #\n        return enum_class\n\n    def __bool__(cls):\n        \"\"\"\n        classes/types should always be True.\n        \"\"\"\n        return True\n\n    def __call__(cls, value, names=_not_given, *values, module=None, qualname=None, type=None, start=1, boundary=None):\n        \"\"\"\n        Either returns an existing member, or creates a new enum class.\n\n        This method is used both when an enum class is given a value to match\n        to an enumeration member (i.e. Color(3)) and for the functional API\n        (i.e. Color = Enum('Color', names='RED GREEN BLUE')).\n\n        The value lookup branch is chosen if the enum is final.\n\n        When used for the functional API:\n\n        `value` will be the name of the new class.\n\n        `names` should be either a string of white-space/comma delimited names\n        (values will start at `start`), or an iterator/mapping of name, value pairs.\n\n        `module` should be set to the module this class is being created in;\n        if it is not set, an attempt to find that module will be made, but if\n        it fails the class will not be picklable.\n\n        `qualname` should be set to the actual location this class can be found\n        at in its module; by default it is set to the global scope.  If this is\n        not correct, unpickling will fail in some circumstances.\n\n        `type`, if set, will be mixed in as the first base class.\n        \"\"\"\n        if cls._member_map_:\n            # simple value lookup if members exist\n            if names is not _not_given:\n                value = (value, names) + values\n            return cls.__new__(cls, value)\n        # otherwise, functional API: we're creating a new Enum type\n        if names is _not_given and type is None:\n            # no body? no data-type? possibly wrong usage\n            raise TypeError(\n                    f\"{cls} has no members; specify `names=()` if you meant to create a new, empty, enum\"\n                    )\n        return cls._create_(\n                class_name=value,\n                names=None if names is _not_given else names,\n                module=module,\n                qualname=qualname,\n                type=type,\n                start=start,\n                boundary=boundary,\n                )\n\n    def __contains__(cls, value):\n        \"\"\"Return True if `value` is in `cls`.\n\n        `value` is in `cls` if:\n        1) `value` is a member of `cls`, or\n        2) `value` is the value of one of the `cls`'s members.\n        \"\"\"\n        if isinstance(value, cls):\n            return True\n        return value in cls._value2member_map_ or value in cls._unhashable_values_\n\n    def __delattr__(cls, attr):\n        # nicer error message when someone tries to delete an attribute\n        # (see issue19025).\n        if attr in cls._member_map_:\n            raise AttributeError(\"%r cannot delete member %r.\" % (cls.__name__, attr))\n        super().__delattr__(attr)\n\n    def __dir__(cls):\n        interesting = set([\n                '__class__', '__contains__', '__doc__', '__getitem__',\n                '__iter__', '__len__', '__members__', '__module__',\n                '__name__', '__qualname__',\n                ]\n                + cls._member_names_\n                )\n        if cls._new_member_ is not object.__new__:\n            interesting.add('__new__')\n        if cls.__init_subclass__ is not object.__init_subclass__:\n            interesting.add('__init_subclass__')\n        if cls._member_type_ is object:\n            return sorted(interesting)\n        else:\n            # return whatever mixed-in data type has\n            return sorted(set(dir(cls._member_type_)) | interesting)\n\n    def __getitem__(cls, name):\n        \"\"\"\n        Return the member matching `name`.\n        \"\"\"\n        return cls._member_map_[name]\n\n    def __iter__(cls):\n        \"\"\"\n        Return members in definition order.\n        \"\"\"\n        return (cls._member_map_[name] for name in cls._member_names_)\n\n    def __len__(cls):\n        \"\"\"\n        Return the number of members (no aliases)\n        \"\"\"\n        return len(cls._member_names_)\n\n    @bltns.property\n    def __members__(cls):\n        \"\"\"\n        Returns a mapping of member name->value.\n\n        This mapping lists all enum members, including aliases. Note that this\n        is a read-only view of the internal mapping.\n        \"\"\"\n        return MappingProxyType(cls._member_map_)\n\n    def __repr__(cls):\n        if Flag is not None and issubclass(cls, Flag):\n            return \"<flag %r>\" % cls.__name__\n        else:\n            return \"<enum %r>\" % cls.__name__\n\n    def __reversed__(cls):\n        \"\"\"\n        Return members in reverse definition order.\n        \"\"\"\n        return (cls._member_map_[name] for name in reversed(cls._member_names_))\n\n    def __setattr__(cls, name, value):\n        \"\"\"\n        Block attempts to reassign Enum members.\n\n        A simple assignment to the class namespace only changes one of the\n        several possible ways to get an Enum member from the Enum class,\n        resulting in an inconsistent Enumeration.\n        \"\"\"\n        member_map = cls.__dict__.get('_member_map_', {})\n        if name in member_map:\n            raise AttributeError('cannot reassign member %r' % (name, ))\n        super().__setattr__(name, value)\n\n    def _create_(cls, class_name, names, *, module=None, qualname=None, type=None, start=1, boundary=None):\n        \"\"\"\n        Convenience method to create a new Enum class.\n\n        `names` can be:\n\n        * A string containing member names, separated either with spaces or\n          commas.  Values are incremented by 1 from `start`.\n        * An iterable of member names.  Values are incremented by 1 from `start`.\n        * An iterable of (member name, value) pairs.\n        * A mapping of member name -> value pairs.\n        \"\"\"\n        metacls = cls.__class__\n        bases = (cls, ) if type is None else (type, cls)\n        _, first_enum = cls._get_mixins_(class_name, bases)\n        classdict = metacls.__prepare__(class_name, bases)\n\n        # special processing needed for names?\n        if isinstance(names, str):\n            names = names.replace(',', ' ').split()\n        if isinstance(names, (tuple, list)) and names and isinstance(names[0], str):\n            original_names, names = names, []\n            last_values = []\n            for count, name in enumerate(original_names):\n                value = first_enum._generate_next_value_(name, start, count, last_values[:])\n                last_values.append(value)\n                names.append((name, value))\n        if names is None:\n            names = ()\n\n        # Here, names is either an iterable of (name, value) or a mapping.\n        for item in names:\n            if isinstance(item, str):\n                member_name, member_value = item, names[item]\n            else:\n                member_name, member_value = item\n            classdict[member_name] = member_value\n\n        if module is None:\n            try:\n                module = sys._getframemodulename(2)\n            except AttributeError:\n                # Fall back on _getframe if _getframemodulename is missing\n                try:\n                    module = sys._getframe(2).f_globals['__name__']\n                except (AttributeError, ValueError, KeyError):\n                    pass\n        if module is None:\n            _make_class_unpicklable(classdict)\n        else:\n            classdict['__module__'] = module\n        if qualname is not None:\n            classdict['__qualname__'] = qualname\n\n        return metacls.__new__(metacls, class_name, bases, classdict, boundary=boundary)\n\n    def _convert_(cls, name, module, filter, source=None, *, boundary=None, as_global=False):\n        \"\"\"\n        Create a new Enum subclass that replaces a collection of global constants\n        \"\"\"\n        # convert all constants from source (or module) that pass filter() to\n        # a new Enum called name, and export the enum and its members back to\n        # module;\n        # also, replace the __reduce_ex__ method so unpickling works in\n        # previous Python versions\n        module_globals = sys.modules[module].__dict__\n        if source:\n            source = source.__dict__\n        else:\n            source = module_globals\n        # _value2member_map_ is populated in the same order every time\n        # for a consistent reverse mapping of number to name when there\n        # are multiple names for the same number.\n        members = [\n                (name, value)\n                for name, value in source.items()\n                if filter(name)]\n        try:\n            # sort by value\n            members.sort(key=lambda t: (t[1], t[0]))\n        except TypeError:\n            # unless some values aren't comparable, in which case sort by name\n            members.sort(key=lambda t: t[0])\n        body = {t[0]: t[1] for t in members}\n        body['__module__'] = module\n        tmp_cls = type(name, (object, ), body)\n        cls = _simple_enum(etype=cls, boundary=boundary or KEEP)(tmp_cls)\n        if as_global:\n            global_enum(cls)\n        else:\n            sys.modules[cls.__module__].__dict__.update(cls.__members__)\n        module_globals[name] = cls\n        return cls\n\n    @classmethod\n    def _check_for_existing_members_(mcls, class_name, bases):\n        for chain in bases:\n            for base in chain.__mro__:\n                if isinstance(base, EnumType) and base._member_names_:\n                    raise TypeError(\n                            \"<enum %r> cannot extend %r\"\n                            % (class_name, base)\n                            )\n\n    @classmethod\n    def _get_mixins_(mcls, class_name, bases):\n        \"\"\"\n        Returns the type for creating enum members, and the first inherited\n        enum class.\n\n        bases: the tuple of bases that was given to __new__\n        \"\"\"\n        if not bases:\n            return object, Enum\n        # ensure final parent class is an Enum derivative, find any concrete\n        # data type, and check that Enum has no members\n        first_enum = bases[-1]\n        if not isinstance(first_enum, EnumType):\n            raise TypeError(\"new enumerations should be created as \"\n                    \"`EnumName([mixin_type, ...] [data_type,] enum_type)`\")\n        member_type = mcls._find_data_type_(class_name, bases) or object\n        return member_type, first_enum\n\n    @classmethod\n    def _find_data_repr_(mcls, class_name, bases):\n        for chain in bases:\n            for base in chain.__mro__:\n                if base is object:\n                    continue\n                elif isinstance(base, EnumType):\n                    # if we hit an Enum, use it's _value_repr_\n                    return base._value_repr_\n                elif '__repr__' in base.__dict__:\n                    # this is our data repr\n                    # double-check if a dataclass with a default __repr__\n                    if (\n                            '__dataclass_fields__' in base.__dict__\n                            and '__dataclass_params__' in base.__dict__\n                            and base.__dict__['__dataclass_params__'].repr\n                        ):\n                        return _dataclass_repr\n                    else:\n                        return base.__dict__['__repr__']\n        return None\n\n    @classmethod\n    def _find_data_type_(mcls, class_name, bases):\n        # a datatype has a __new__ method, or a __dataclass_fields__ attribute\n        data_types = set()\n        base_chain = set()\n        for chain in bases:\n            candidate = None\n            for base in chain.__mro__:\n                base_chain.add(base)\n                if base is object:\n                    continue\n                elif isinstance(base, EnumType):\n                    if base._member_type_ is not object:\n                        data_types.add(base._member_type_)\n                        break\n                elif '__new__' in base.__dict__ or '__dataclass_fields__' in base.__dict__:\n                    data_types.add(candidate or base)\n                    break\n                else:\n                    candidate = candidate or base\n        if len(data_types) > 1:\n            raise TypeError('too many data types for %r: %r' % (class_name, data_types))\n        elif data_types:\n            return data_types.pop()\n        else:\n            return None\n\n    @classmethod\n    def _find_new_(mcls, classdict, member_type, first_enum):\n        \"\"\"\n        Returns the __new__ to be used for creating the enum members.\n\n        classdict: the class dictionary given to __new__\n        member_type: the data type whose __new__ will be used by default\n        first_enum: enumeration to check for an overriding __new__\n        \"\"\"\n        # now find the correct __new__, checking to see of one was defined\n        # by the user; also check earlier enum classes in case a __new__ was\n        # saved as __new_member__\n        __new__ = classdict.get('__new__', None)\n\n        # should __new__ be saved as __new_member__ later?\n        save_new = first_enum is not None and __new__ is not None\n\n        if __new__ is None:\n            # check all possibles for __new_member__ before falling back to\n            # __new__\n            for method in ('__new_member__', '__new__'):\n                for possible in (member_type, first_enum):\n                    target = getattr(possible, method, None)\n                    if target not in {\n                            None,\n                            None.__new__,\n                            object.__new__,\n                            Enum.__new__,\n                            }:\n                        __new__ = target\n                        break\n                if __new__ is not None:\n                    break\n            else:\n                __new__ = object.__new__\n\n        # if a non-object.__new__ is used then whatever value/tuple was\n        # assigned to the enum member name will be passed to __new__ and to the\n        # new enum member's __init__\n        if first_enum is None or __new__ in (Enum.__new__, object.__new__):\n            use_args = False\n        else:\n            use_args = True\n        return __new__, save_new, use_args\nEnumMeta = EnumType\n\n\nclass Enum(metaclass=EnumType):\n    \"\"\"\n    Create a collection of name/value pairs.\n\n    Example enumeration:\n\n    >>> class Color(Enum):\n    ...     RED = 1\n    ...     BLUE = 2\n    ...     GREEN = 3\n\n    Access them by:\n\n    - attribute access:\n\n      >>> Color.RED\n      <Color.RED: 1>\n\n    - value lookup:\n\n      >>> Color(1)\n      <Color.RED: 1>\n\n    - name lookup:\n\n      >>> Color['RED']\n      <Color.RED: 1>\n\n    Enumerations can be iterated over, and know how many members they have:\n\n    >>> len(Color)\n    3\n\n    >>> list(Color)\n    [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\n    Methods can be added to enumerations, and members can have their own\n    attributes -- see the documentation for details.\n    \"\"\"\n\n    @classmethod\n    def __signature__(cls):\n        if cls._member_names_:\n            return '(*values)'\n        else:\n            return '(new_class_name, /, names, *, module=None, qualname=None, type=None, start=1, boundary=None)'\n\n    def __new__(cls, value):\n        # all enum instances are actually created during class construction\n        # without calling this method; this method is called by the metaclass'\n        # __call__ (i.e. Color(3) ), and by pickle\n        if type(value) is cls:\n            # For lookups like Color(Color.RED)\n            return value\n        # by-value search for a matching enum member\n        # see if it's in the reverse mapping (for hashable values)\n        try:\n            return cls._value2member_map_[value]\n        except KeyError:\n            # Not found, no need to do long O(n) search\n            pass\n        except TypeError:\n            # not there, now do long search -- O(n) behavior\n            for member in cls._member_map_.values():\n                if member._value_ == value:\n                    return member\n        # still not found -- verify that members exist, in-case somebody got here mistakenly\n        # (such as via super when trying to override __new__)\n        if not cls._member_map_:\n            raise TypeError(\"%r has no members defined\" % cls)\n        #\n        # still not found -- try _missing_ hook\n        try:\n            exc = None\n            result = cls._missing_(value)\n        except Exception as e:\n            exc = e\n            result = None\n        try:\n            if isinstance(result, cls):\n                return result\n            elif (\n                    Flag is not None and issubclass(cls, Flag)\n                    and cls._boundary_ is EJECT and isinstance(result, int)\n                ):\n                return result\n            else:\n                ve_exc = ValueError(\"%r is not a valid %s\" % (value, cls.__qualname__))\n                if result is None and exc is None:\n                    raise ve_exc\n                elif exc is None:\n                    exc = TypeError(\n                            'error in %s._missing_: returned %r instead of None or a valid member'\n                            % (cls.__name__, result)\n                            )\n                if not isinstance(exc, ValueError):\n                    exc.__context__ = ve_exc\n                raise exc\n        finally:\n            # ensure all variables that could hold an exception are destroyed\n            exc = None\n            ve_exc = None\n\n    def __init__(self, *args, **kwds):\n        pass\n\n    @staticmethod\n    def _generate_next_value_(name, start, count, last_values):\n        \"\"\"\n        Generate the next value when not given.\n\n        name: the name of the member\n        start: the initial start value or None\n        count: the number of existing members\n        last_values: the list of values assigned\n        \"\"\"\n        if not last_values:\n            return start\n        try:\n            last = last_values[-1]\n            last_values.sort()\n            if last == last_values[-1]:\n                # no difference between old and new methods\n                return last + 1\n            else:\n                # trigger old method (with warning)\n                raise TypeError\n        except TypeError:\n            import warnings\n            warnings.warn(\n                    \"In 3.13 the default `auto()`/`_generate_next_value_` will require all values to be sortable and support adding +1\\n\"\n                    \"and the value returned will be the largest value in the enum incremented by 1\",\n                    DeprecationWarning,\n                    stacklevel=3,\n                    )\n            for v in reversed(last_values):\n                try:\n                    return v + 1\n                except TypeError:\n                    pass\n            return start\n\n    @classmethod\n    def _missing_(cls, value):\n        return None\n\n    def __repr__(self):\n        v_repr = self.__class__._value_repr_ or repr\n        return \"<%s.%s: %s>\" % (self.__class__.__name__, self._name_, v_repr(self._value_))\n\n    def __str__(self):\n        return \"%s.%s\" % (self.__class__.__name__, self._name_, )\n\n    def __dir__(self):\n        \"\"\"\n        Returns public methods and other interesting attributes.\n        \"\"\"\n        interesting = set()\n        if self.__class__._member_type_ is not object:\n            interesting = set(object.__dir__(self))\n        for name in getattr(self, '__dict__', []):\n            if name[0] != '_' and name not in self._member_map_:\n                interesting.add(name)\n        for cls in self.__class__.mro():\n            for name, obj in cls.__dict__.items():\n                if name[0] == '_':\n                    continue\n                if isinstance(obj, property):\n                    # that's an enum.property\n                    if obj.fget is not None or name not in self._member_map_:\n                        interesting.add(name)\n                    else:\n                        # in case it was added by `dir(self)`\n                        interesting.discard(name)\n                elif name not in self._member_map_:\n                    interesting.add(name)\n        names = sorted(\n                set(['__class__', '__doc__', '__eq__', '__hash__', '__module__'])\n                | interesting\n                )\n        return names\n\n    def __format__(self, format_spec):\n        return str.__format__(str(self), format_spec)\n\n    def __hash__(self):\n        return hash(self._name_)\n\n    def __reduce_ex__(self, proto):\n        return self.__class__, (self._value_, )\n\n    def __deepcopy__(self,memo):\n        return self\n\n    def __copy__(self):\n        return self\n\n    # enum.property is used to provide access to the `name` and\n    # `value` attributes of enum members while keeping some measure of\n    # protection from modification, while still allowing for an enumeration\n    # to have members named `name` and `value`.  This works because each\n    # instance of enum.property saves its companion member, which it returns\n    # on class lookup; on instance lookup it either executes a provided function\n    # or raises an AttributeError.\n\n    @property\n    def name(self):\n        \"\"\"The name of the Enum member.\"\"\"\n        return self._name_\n\n    @property\n    def value(self):\n        \"\"\"The value of the Enum member.\"\"\"\n        return self._value_\n\n\nclass ReprEnum(Enum):\n    \"\"\"\n    Only changes the repr(), leaving str() and format() to the mixed-in type.\n    \"\"\"\n\n\nclass IntEnum(int, ReprEnum):\n    \"\"\"\n    Enum where members are also (and must be) ints\n    \"\"\"\n\n\nclass StrEnum(str, ReprEnum):\n    \"\"\"\n    Enum where members are also (and must be) strings\n    \"\"\"\n\n    def __new__(cls, *values):\n        \"values must already be of type `str`\"\n        if len(values) > 3:\n            raise TypeError('too many arguments for str(): %r' % (values, ))\n        if len(values) == 1:\n            # it must be a string\n            if not isinstance(values[0], str):\n                raise TypeError('%r is not a string' % (values[0], ))\n        if len(values) >= 2:\n            # check that encoding argument is a string\n            if not isinstance(values[1], str):\n                raise TypeError('encoding must be a string, not %r' % (values[1], ))\n        if len(values) == 3:\n            # check that errors argument is a string\n            if not isinstance(values[2], str):\n                raise TypeError('errors must be a string, not %r' % (values[2]))\n        value = str(*values)\n        member = str.__new__(cls, value)\n        member._value_ = value\n        return member\n\n    @staticmethod\n    def _generate_next_value_(name, start, count, last_values):\n        \"\"\"\n        Return the lower-cased version of the member name.\n        \"\"\"\n        return name.lower()\n\n\ndef pickle_by_global_name(self, proto):\n    # should not be used with Flag-type enums\n    return self.name\n_reduce_ex_by_global_name = pickle_by_global_name\n\ndef pickle_by_enum_name(self, proto):\n    # should not be used with Flag-type enums\n    return getattr, (self.__class__, self._name_)\n\nclass FlagBoundary(StrEnum):\n    \"\"\"\n    control how out of range values are handled\n    \"strict\" -> error is raised             [default for Flag]\n    \"conform\" -> extra bits are discarded\n    \"eject\" -> lose flag status\n    \"keep\" -> keep flag status and all bits [default for IntFlag]\n    \"\"\"\n    STRICT = auto()\n    CONFORM = auto()\n    EJECT = auto()\n    KEEP = auto()\nSTRICT, CONFORM, EJECT, KEEP = FlagBoundary\n\n\nclass Flag(Enum, boundary=STRICT):\n    \"\"\"\n    Support for flags\n    \"\"\"\n\n    _numeric_repr_ = repr\n\n    @staticmethod\n    def _generate_next_value_(name, start, count, last_values):\n        \"\"\"\n        Generate the next value when not given.\n\n        name: the name of the member\n        start: the initial start value or None\n        count: the number of existing members\n        last_values: the last value assigned or None\n        \"\"\"\n        if not count:\n            return start if start is not None else 1\n        last_value = max(last_values)\n        try:\n            high_bit = _high_bit(last_value)\n        except Exception:\n            raise TypeError('invalid flag value %r' % last_value) from None\n        return 2 ** (high_bit+1)\n\n    @classmethod\n    def _iter_member_by_value_(cls, value):\n        \"\"\"\n        Extract all members from the value in definition (i.e. increasing value) order.\n        \"\"\"\n        for val in _iter_bits_lsb(value & cls._flag_mask_):\n            yield cls._value2member_map_.get(val)\n\n    _iter_member_ = _iter_member_by_value_\n\n    @classmethod\n    def _iter_member_by_def_(cls, value):\n        \"\"\"\n        Extract all members from the value in definition order.\n        \"\"\"\n        yield from sorted(\n                cls._iter_member_by_value_(value),\n                key=lambda m: m._sort_order_,\n                )\n\n    @classmethod\n    def _missing_(cls, value):\n        \"\"\"\n        Create a composite member containing all canonical members present in `value`.\n\n        If non-member values are present, result depends on `_boundary_` setting.\n        \"\"\"\n        if not isinstance(value, int):\n            raise ValueError(\n                    \"%r is not a valid %s\" % (value, cls.__qualname__)\n                    )\n        # check boundaries\n        # - value must be in range (e.g. -16 <-> +15, i.e. ~15 <-> 15)\n        # - value must not include any skipped flags (e.g. if bit 2 is not\n        #   defined, then 0d10 is invalid)\n        flag_mask = cls._flag_mask_\n        singles_mask = cls._singles_mask_\n        all_bits = cls._all_bits_\n        neg_value = None\n        if (\n                not ~all_bits <= value <= all_bits\n                or value & (all_bits ^ flag_mask)\n            ):\n            if cls._boundary_ is STRICT:\n                max_bits = max(value.bit_length(), flag_mask.bit_length())\n                raise ValueError(\n                        \"%r invalid value %r\\n    given %s\\n  allowed %s\" % (\n                            cls, value, bin(value, max_bits), bin(flag_mask, max_bits),\n                            ))\n            elif cls._boundary_ is CONFORM:\n                value = value & flag_mask\n            elif cls._boundary_ is EJECT:\n                return value\n            elif cls._boundary_ is KEEP:\n                if value < 0:\n                    value = (\n                            max(all_bits+1, 2**(value.bit_length()))\n                            + value\n                            )\n            else:\n                raise ValueError(\n                        '%r unknown flag boundary %r' % (cls, cls._boundary_, )\n                        )\n        if value < 0:\n            neg_value = value\n            value = all_bits + 1 + value\n        # get members and unknown\n        unknown = value & ~flag_mask\n        aliases = value & ~singles_mask\n        member_value = value & singles_mask\n        if unknown and cls._boundary_ is not KEEP:\n            raise ValueError(\n                    '%s(%r) -->  unknown values %r [%s]'\n                    % (cls.__name__, value, unknown, bin(unknown))\n                    )\n        # normal Flag?\n        if cls._member_type_ is object:\n            # construct a singleton enum pseudo-member\n            pseudo_member = object.__new__(cls)\n        else:\n            pseudo_member = cls._member_type_.__new__(cls, value)\n        if not hasattr(pseudo_member, '_value_'):\n            pseudo_member._value_ = value\n        if member_value or aliases:\n            members = []\n            combined_value = 0\n            for m in cls._iter_member_(member_value):\n                members.append(m)\n                combined_value |= m._value_\n            if aliases:\n                value = member_value | aliases\n                for n, pm in cls._member_map_.items():\n                    if pm not in members and pm._value_ and pm._value_ & value == pm._value_:\n                        members.append(pm)\n                        combined_value |= pm._value_\n            unknown = value ^ combined_value\n            pseudo_member._name_ = '|'.join([m._name_ for m in members])\n            if not combined_value:\n                pseudo_member._name_ = None\n            elif unknown and cls._boundary_ is STRICT:\n                raise ValueError('%r: no members with value %r' % (cls, unknown))\n            elif unknown:\n                pseudo_member._name_ += '|%s' % cls._numeric_repr_(unknown)\n        else:\n            pseudo_member._name_ = None\n        # use setdefault in case another thread already created a composite\n        # with this value\n        # note: zero is a special case -- always add it\n        pseudo_member = cls._value2member_map_.setdefault(value, pseudo_member)\n        if neg_value is not None:\n            cls._value2member_map_[neg_value] = pseudo_member\n        return pseudo_member\n\n    def __contains__(self, other):\n        \"\"\"\n        Returns True if self has at least the same flags set as other.\n        \"\"\"\n        if not isinstance(other, self.__class__):\n            raise TypeError(\n                \"unsupported operand type(s) for 'in': %r and %r\" % (\n                    type(other).__qualname__, self.__class__.__qualname__))\n        return other._value_ & self._value_ == other._value_\n\n    def __iter__(self):\n        \"\"\"\n        Returns flags in definition order.\n        \"\"\"\n        yield from self._iter_member_(self._value_)\n\n    def __len__(self):\n        return self._value_.bit_count()\n\n    def __repr__(self):\n        cls_name = self.__class__.__name__\n        v_repr = self.__class__._value_repr_ or repr\n        if self._name_ is None:\n            return \"<%s: %s>\" % (cls_name, v_repr(self._value_))\n        else:\n            return \"<%s.%s: %s>\" % (cls_name, self._name_, v_repr(self._value_))\n\n    def __str__(self):\n        cls_name = self.__class__.__name__\n        if self._name_ is None:\n            return '%s(%r)' % (cls_name, self._value_)\n        else:\n            return \"%s.%s\" % (cls_name, self._name_)\n\n    def __bool__(self):\n        return bool(self._value_)\n\n    def _get_value(self, flag):\n        if isinstance(flag, self.__class__):\n            return flag._value_\n        elif self._member_type_ is not object and isinstance(flag, self._member_type_):\n            return flag\n        return NotImplemented\n\n    def __or__(self, other):\n        other_value = self._get_value(other)\n        if other_value is NotImplemented:\n            return NotImplemented\n\n        for flag in self, other:\n            if self._get_value(flag) is None:\n                raise TypeError(f\"'{flag}' cannot be combined with other flags with |\")\n        value = self._value_\n        return self.__class__(value | other_value)\n\n    def __and__(self, other):\n        other_value = self._get_value(other)\n        if other_value is NotImplemented:\n            return NotImplemented\n\n        for flag in self, other:\n            if self._get_value(flag) is None:\n                raise TypeError(f\"'{flag}' cannot be combined with other flags with &\")\n        value = self._value_\n        return self.__class__(value & other_value)\n\n    def __xor__(self, other):\n        other_value = self._get_value(other)\n        if other_value is NotImplemented:\n            return NotImplemented\n\n        for flag in self, other:\n            if self._get_value(flag) is None:\n                raise TypeError(f\"'{flag}' cannot be combined with other flags with ^\")\n        value = self._value_\n        return self.__class__(value ^ other_value)\n\n    def __invert__(self):\n        if self._get_value(self) is None:\n            raise TypeError(f\"'{self}' cannot be inverted\")\n\n        if self._inverted_ is None:\n            if self._boundary_ in (EJECT, KEEP):\n                self._inverted_ = self.__class__(~self._value_)\n            else:\n                self._inverted_ = self.__class__(self._singles_mask_ & ~self._value_)\n        return self._inverted_\n\n    __rand__ = __and__\n    __ror__ = __or__\n    __rxor__ = __xor__\n\n\nclass IntFlag(int, ReprEnum, Flag, boundary=KEEP):\n    \"\"\"\n    Support for integer-based Flags\n    \"\"\"\n\n\ndef _high_bit(value):\n    \"\"\"\n    returns index of highest bit, or -1 if value is zero or negative\n    \"\"\"\n    return value.bit_length() - 1\n\ndef unique(enumeration):\n    \"\"\"\n    Class decorator for enumerations ensuring unique member values.\n    \"\"\"\n    duplicates = []\n    for name, member in enumeration.__members__.items():\n        if name != member.name:\n            duplicates.append((name, member.name))\n    if duplicates:\n        alias_details = ', '.join(\n                [\"%s -> %s\" % (alias, name) for (alias, name) in duplicates])\n        raise ValueError('duplicate values found in %r: %s' %\n                (enumeration, alias_details))\n    return enumeration\n\ndef _dataclass_repr(self):\n    dcf = self.__dataclass_fields__\n    return ', '.join(\n            '%s=%r' % (k, getattr(self, k))\n            for k in dcf.keys()\n            if dcf[k].repr\n            )\n\ndef global_enum_repr(self):\n    \"\"\"\n    use module.enum_name instead of class.enum_name\n\n    the module is the last module in case of a multi-module name\n    \"\"\"\n    module = self.__class__.__module__.split('.')[-1]\n    return '%s.%s' % (module, self._name_)\n\ndef global_flag_repr(self):\n    \"\"\"\n    use module.flag_name instead of class.flag_name\n\n    the module is the last module in case of a multi-module name\n    \"\"\"\n    module = self.__class__.__module__.split('.')[-1]\n    cls_name = self.__class__.__name__\n    if self._name_ is None:\n        return \"%s.%s(%r)\" % (module, cls_name, self._value_)\n    if _is_single_bit(self._value_):\n        return '%s.%s' % (module, self._name_)\n    if self._boundary_ is not FlagBoundary.KEEP:\n        return '|'.join(['%s.%s' % (module, name) for name in self.name.split('|')])\n    else:\n        name = []\n        for n in self._name_.split('|'):\n            if n[0].isdigit():\n                name.append(n)\n            else:\n                name.append('%s.%s' % (module, n))\n        return '|'.join(name)\n\ndef global_str(self):\n    \"\"\"\n    use enum_name instead of class.enum_name\n    \"\"\"\n    if self._name_ is None:\n        cls_name = self.__class__.__name__\n        return \"%s(%r)\" % (cls_name, self._value_)\n    else:\n        return self._name_\n\ndef global_enum(cls, update_str=False):\n    \"\"\"\n    decorator that makes the repr() of an enum member reference its module\n    instead of its class; also exports all members to the enum's module's\n    global namespace\n    \"\"\"\n    if issubclass(cls, Flag):\n        cls.__repr__ = global_flag_repr\n    else:\n        cls.__repr__ = global_enum_repr\n    if not issubclass(cls, ReprEnum) or update_str:\n        cls.__str__ = global_str\n    sys.modules[cls.__module__].__dict__.update(cls.__members__)\n    return cls\n\ndef _simple_enum(etype=Enum, *, boundary=None, use_args=None):\n    \"\"\"\n    Class decorator that converts a normal class into an :class:`Enum`.  No\n    safety checks are done, and some advanced behavior (such as\n    :func:`__init_subclass__`) is not available.  Enum creation can be faster\n    using :func:`simple_enum`.\n\n        >>> from enum import Enum, _simple_enum\n        >>> @_simple_enum(Enum)\n        ... class Color:\n        ...     RED = auto()\n        ...     GREEN = auto()\n        ...     BLUE = auto()\n        >>> Color\n        <enum 'Color'>\n    \"\"\"\n    def convert_class(cls):\n        nonlocal use_args\n        cls_name = cls.__name__\n        if use_args is None:\n            use_args = etype._use_args_\n        __new__ = cls.__dict__.get('__new__')\n        if __new__ is not None:\n            new_member = __new__.__func__\n        else:\n            new_member = etype._member_type_.__new__\n        attrs = {}\n        body = {}\n        if __new__ is not None:\n            body['__new_member__'] = new_member\n        body['_new_member_'] = new_member\n        body['_use_args_'] = use_args\n        body['_generate_next_value_'] = gnv = etype._generate_next_value_\n        body['_member_names_'] = member_names = []\n        body['_member_map_'] = member_map = {}\n        body['_value2member_map_'] = value2member_map = {}\n        body['_unhashable_values_'] = []\n        body['_member_type_'] = member_type = etype._member_type_\n        body['_value_repr_'] = etype._value_repr_\n        if issubclass(etype, Flag):\n            body['_boundary_'] = boundary or etype._boundary_\n            body['_flag_mask_'] = None\n            body['_all_bits_'] = None\n            body['_singles_mask_'] = None\n            body['_inverted_'] = None\n            body['__or__'] = Flag.__or__\n            body['__xor__'] = Flag.__xor__\n            body['__and__'] = Flag.__and__\n            body['__ror__'] = Flag.__ror__\n            body['__rxor__'] = Flag.__rxor__\n            body['__rand__'] = Flag.__rand__\n            body['__invert__'] = Flag.__invert__\n        for name, obj in cls.__dict__.items():\n            if name in ('__dict__', '__weakref__'):\n                continue\n            if _is_dunder(name) or _is_private(cls_name, name) or _is_sunder(name) or _is_descriptor(obj):\n                body[name] = obj\n            else:\n                attrs[name] = obj\n        if cls.__dict__.get('__doc__') is None:\n            body['__doc__'] = 'An enumeration.'\n        #\n        # double check that repr and friends are not the mixin's or various\n        # things break (such as pickle)\n        # however, if the method is defined in the Enum itself, don't replace\n        # it\n        enum_class = type(cls_name, (etype, ), body, boundary=boundary, _simple=True)\n        for name in ('__repr__', '__str__', '__format__', '__reduce_ex__'):\n            if name not in body:\n                # check for mixin overrides before replacing\n                enum_method = getattr(etype, name)\n                found_method = getattr(enum_class, name)\n                object_method = getattr(object, name)\n                data_type_method = getattr(member_type, name)\n                if found_method in (data_type_method, object_method):\n                    setattr(enum_class, name, enum_method)\n        gnv_last_values = []\n        if issubclass(enum_class, Flag):\n            # Flag / IntFlag\n            single_bits = multi_bits = 0\n            for name, value in attrs.items():\n                if isinstance(value, auto) and auto.value is _auto_null:\n                    value = gnv(name, 1, len(member_names), gnv_last_values)\n                if value in value2member_map:\n                    # an alias to an existing member\n                    member = value2member_map[value]\n                    redirect = property()\n                    redirect.member = member\n                    redirect.__set_name__(enum_class, name)\n                    setattr(enum_class, name, redirect)\n                    member_map[name] = member\n                else:\n                    # create the member\n                    if use_args:\n                        if not isinstance(value, tuple):\n                            value = (value, )\n                        member = new_member(enum_class, *value)\n                        value = value[0]\n                    else:\n                        member = new_member(enum_class)\n                    if __new__ is None:\n                        member._value_ = value\n                    member._name_ = name\n                    member.__objclass__ = enum_class\n                    member.__init__(value)\n                    redirect = property()\n                    redirect.member = member\n                    redirect.__set_name__(enum_class, name)\n                    setattr(enum_class, name, redirect)\n                    member_map[name] = member\n                    member._sort_order_ = len(member_names)\n                    value2member_map[value] = member\n                    if _is_single_bit(value):\n                        # not a multi-bit alias, record in _member_names_ and _flag_mask_\n                        member_names.append(name)\n                        single_bits |= value\n                    else:\n                        multi_bits |= value\n                    gnv_last_values.append(value)\n            enum_class._flag_mask_ = single_bits | multi_bits\n            enum_class._singles_mask_ = single_bits\n            enum_class._all_bits_ = 2 ** ((single_bits|multi_bits).bit_length()) - 1\n            # set correct __iter__\n            member_list = [m._value_ for m in enum_class]\n            if member_list != sorted(member_list):\n                enum_class._iter_member_ = enum_class._iter_member_by_def_\n        else:\n            # Enum / IntEnum / StrEnum\n            for name, value in attrs.items():\n                if isinstance(value, auto):\n                    if value.value is _auto_null:\n                        value.value = gnv(name, 1, len(member_names), gnv_last_values)\n                    value = value.value\n                if value in value2member_map:\n                    # an alias to an existing member\n                    member = value2member_map[value]\n                    redirect = property()\n                    redirect.member = member\n                    redirect.__set_name__(enum_class, name)\n                    setattr(enum_class, name, redirect)\n                    member_map[name] = member\n                else:\n                    # create the member\n                    if use_args:\n                        if not isinstance(value, tuple):\n                            value = (value, )\n                        member = new_member(enum_class, *value)\n                        value = value[0]\n                    else:\n                        member = new_member(enum_class)\n                    if __new__ is None:\n                        member._value_ = value\n                    member._name_ = name\n                    member.__objclass__ = enum_class\n                    member.__init__(value)\n                    member._sort_order_ = len(member_names)\n                    redirect = property()\n                    redirect.member = member\n                    redirect.__set_name__(enum_class, name)\n                    setattr(enum_class, name, redirect)\n                    member_map[name] = member\n                    value2member_map[value] = member\n                    member_names.append(name)\n                    gnv_last_values.append(value)\n        if '__new__' in body:\n            enum_class.__new_member__ = enum_class.__new__\n        enum_class.__new__ = Enum.__new__\n        return enum_class\n    return convert_class\n\n@_simple_enum(StrEnum)\nclass EnumCheck:\n    \"\"\"\n    various conditions to check an enumeration for\n    \"\"\"\n    CONTINUOUS = \"no skipped integer values\"\n    NAMED_FLAGS = \"multi-flag aliases may not contain unnamed flags\"\n    UNIQUE = \"one name per value\"\nCONTINUOUS, NAMED_FLAGS, UNIQUE = EnumCheck\n\n\nclass verify:\n    \"\"\"\n    Check an enumeration for various constraints. (see EnumCheck)\n    \"\"\"\n    def __init__(self, *checks):\n        self.checks = checks\n    def __call__(self, enumeration):\n        checks = self.checks\n        cls_name = enumeration.__name__\n        if Flag is not None and issubclass(enumeration, Flag):\n            enum_type = 'flag'\n        elif issubclass(enumeration, Enum):\n            enum_type = 'enum'\n        else:\n            raise TypeError(\"the 'verify' decorator only works with Enum and Flag\")\n        for check in checks:\n            if check is UNIQUE:\n                # check for duplicate names\n                duplicates = []\n                for name, member in enumeration.__members__.items():\n                    if name != member.name:\n                        duplicates.append((name, member.name))\n                if duplicates:\n                    alias_details = ', '.join(\n                            [\"%s -> %s\" % (alias, name) for (alias, name) in duplicates])\n                    raise ValueError('aliases found in %r: %s' %\n                            (enumeration, alias_details))\n            elif check is CONTINUOUS:\n                values = set(e.value for e in enumeration)\n                if len(values) < 2:\n                    continue\n                low, high = min(values), max(values)\n                missing = []\n                if enum_type == 'flag':\n                    # check for powers of two\n                    for i in range(_high_bit(low)+1, _high_bit(high)):\n                        if 2**i not in values:\n                            missing.append(2**i)\n                elif enum_type == 'enum':\n                    # check for powers of one\n                    for i in range(low+1, high):\n                        if i not in values:\n                            missing.append(i)\n                else:\n                    raise Exception('verify: unknown type %r' % enum_type)\n                if missing:\n                    raise ValueError(('invalid %s %r: missing values %s' % (\n                            enum_type, cls_name, ', '.join((str(m) for m in missing)))\n                            )[:256])\n                            # limit max length to protect against DOS attacks\n            elif check is NAMED_FLAGS:\n                # examine each alias and check for unnamed flags\n                member_names = enumeration._member_names_\n                member_values = [m.value for m in enumeration]\n                missing_names = []\n                missing_value = 0\n                for name, alias in enumeration._member_map_.items():\n                    if name in member_names:\n                        # not an alias\n                        continue\n                    if alias.value < 0:\n                        # negative numbers are not checked\n                        continue\n                    values = list(_iter_bits_lsb(alias.value))\n                    missed = [v for v in values if v not in member_values]\n                    if missed:\n                        missing_names.append(name)\n                        missing_value |= reduce(_or_, missed)\n                if missing_names:\n                    if len(missing_names) == 1:\n                        alias = 'alias %s is missing' % missing_names[0]\n                    else:\n                        alias = 'aliases %s and %s are missing' % (\n                                ', '.join(missing_names[:-1]), missing_names[-1]\n                                )\n                    if _is_single_bit(missing_value):\n                        value = 'value 0x%x' % missing_value\n                    else:\n                        value = 'combined values of 0x%x' % missing_value\n                    raise ValueError(\n                            'invalid Flag %r: %s %s [use enum.show_flag_values(value) for details]'\n                            % (cls_name, alias, value)\n                            )\n        return enumeration\n\ndef _test_simple_enum(checked_enum, simple_enum):\n    \"\"\"\n    A function that can be used to test an enum created with :func:`_simple_enum`\n    against the version created by subclassing :class:`Enum`::\n\n        >>> from enum import Enum, _simple_enum, _test_simple_enum\n        >>> @_simple_enum(Enum)\n        ... class Color:\n        ...     RED = auto()\n        ...     GREEN = auto()\n        ...     BLUE = auto()\n        >>> class CheckedColor(Enum):\n        ...     RED = auto()\n        ...     GREEN = auto()\n        ...     BLUE = auto()\n        >>> _test_simple_enum(CheckedColor, Color)\n\n    If differences are found, a :exc:`TypeError` is raised.\n    \"\"\"\n    failed = []\n    if checked_enum.__dict__ != simple_enum.__dict__:\n        checked_dict = checked_enum.__dict__\n        checked_keys = list(checked_dict.keys())\n        simple_dict = simple_enum.__dict__\n        simple_keys = list(simple_dict.keys())\n        member_names = set(\n                list(checked_enum._member_map_.keys())\n                + list(simple_enum._member_map_.keys())\n                )\n        for key in set(checked_keys + simple_keys):\n            if key in ('__module__', '_member_map_', '_value2member_map_', '__doc__'):\n                # keys known to be different, or very long\n                continue\n            elif key in member_names:\n                # members are checked below\n                continue\n            elif key not in simple_keys:\n                failed.append(\"missing key: %r\" % (key, ))\n            elif key not in checked_keys:\n                failed.append(\"extra key:   %r\" % (key, ))\n            else:\n                checked_value = checked_dict[key]\n                simple_value = simple_dict[key]\n                if callable(checked_value) or isinstance(checked_value, bltns.property):\n                    continue\n                if key == '__doc__':\n                    # remove all spaces/tabs\n                    compressed_checked_value = checked_value.replace(' ','').replace('\\t','')\n                    compressed_simple_value = simple_value.replace(' ','').replace('\\t','')\n                    if compressed_checked_value != compressed_simple_value:\n                        failed.append(\"%r:\\n         %s\\n         %s\" % (\n                                key,\n                                \"checked -> %r\" % (checked_value, ),\n                                \"simple  -> %r\" % (simple_value, ),\n                                ))\n                elif checked_value != simple_value:\n                    failed.append(\"%r:\\n         %s\\n         %s\" % (\n                            key,\n                            \"checked -> %r\" % (checked_value, ),\n                            \"simple  -> %r\" % (simple_value, ),\n                            ))\n        failed.sort()\n        for name in member_names:\n            failed_member = []\n            if name not in simple_keys:\n                failed.append('missing member from simple enum: %r' % name)\n            elif name not in checked_keys:\n                failed.append('extra member in simple enum: %r' % name)\n            else:\n                checked_member_dict = checked_enum[name].__dict__\n                checked_member_keys = list(checked_member_dict.keys())\n                simple_member_dict = simple_enum[name].__dict__\n                simple_member_keys = list(simple_member_dict.keys())\n                for key in set(checked_member_keys + simple_member_keys):\n                    if key in ('__module__', '__objclass__', '_inverted_'):\n                        # keys known to be different or absent\n                        continue\n                    elif key not in simple_member_keys:\n                        failed_member.append(\"missing key %r not in the simple enum member %r\" % (key, name))\n                    elif key not in checked_member_keys:\n                        failed_member.append(\"extra key %r in simple enum member %r\" % (key, name))\n                    else:\n                        checked_value = checked_member_dict[key]\n                        simple_value = simple_member_dict[key]\n                        if checked_value != simple_value:\n                            failed_member.append(\"%r:\\n         %s\\n         %s\" % (\n                                    key,\n                                    \"checked member -> %r\" % (checked_value, ),\n                                    \"simple member  -> %r\" % (simple_value, ),\n                                    ))\n            if failed_member:\n                failed.append('%r member mismatch:\\n      %s' % (\n                        name, '\\n      '.join(failed_member),\n                        ))\n        for method in (\n                '__str__', '__repr__', '__reduce_ex__', '__format__',\n                '__getnewargs_ex__', '__getnewargs__', '__reduce_ex__', '__reduce__'\n            ):\n            if method in simple_keys and method in checked_keys:\n                # cannot compare functions, and it exists in both, so we're good\n                continue\n            elif method not in simple_keys and method not in checked_keys:\n                # method is inherited -- check it out\n                checked_method = getattr(checked_enum, method, None)\n                simple_method = getattr(simple_enum, method, None)\n                if hasattr(checked_method, '__func__'):\n                    checked_method = checked_method.__func__\n                    simple_method = simple_method.__func__\n                if checked_method != simple_method:\n                    failed.append(\"%r:  %-30s %s\" % (\n                            method,\n                            \"checked -> %r\" % (checked_method, ),\n                            \"simple -> %r\" % (simple_method, ),\n                            ))\n            else:\n                # if the method existed in only one of the enums, it will have been caught\n                # in the first checks above\n                pass\n    if failed:\n        raise TypeError('enum mismatch:\\n   %s' % '\\n   '.join(failed))\n\ndef _old_convert_(etype, name, module, filter, source=None, *, boundary=None):\n    \"\"\"\n    Create a new Enum subclass that replaces a collection of global constants\n    \"\"\"\n    # convert all constants from source (or module) that pass filter() to\n    # a new Enum called name, and export the enum and its members back to\n    # module;\n    # also, replace the __reduce_ex__ method so unpickling works in\n    # previous Python versions\n    module_globals = sys.modules[module].__dict__\n    if source:\n        source = source.__dict__\n    else:\n        source = module_globals\n    # _value2member_map_ is populated in the same order every time\n    # for a consistent reverse mapping of number to name when there\n    # are multiple names for the same number.\n    members = [\n            (name, value)\n            for name, value in source.items()\n            if filter(name)]\n    try:\n        # sort by value\n        members.sort(key=lambda t: (t[1], t[0]))\n    except TypeError:\n        # unless some values aren't comparable, in which case sort by name\n        members.sort(key=lambda t: t[0])\n    cls = etype(name, members, module=module, boundary=boundary or KEEP)\n    return cls\n\n_stdlib_enums = IntEnum, StrEnum, IntFlag\n", 2109], "/opt/anaconda3/lib/python3.12/site-packages/zmq/sugar/socket.py": ["\"\"\"0MQ Socket pure Python methods.\"\"\"\n\n# Copyright (C) PyZMQ Developers\n# Distributed under the terms of the Modified BSD License.\n\n\nimport errno\nimport pickle\nimport random\nimport sys\nfrom typing import (\n    Any,\n    Callable,\n    Dict,\n    Generic,\n    List,\n    Optional,\n    Sequence,\n    Type,\n    TypeVar,\n    Union,\n    cast,\n    overload,\n)\nfrom warnings import warn\n\nimport zmq\nfrom zmq._typing import Literal\nfrom zmq.backend import Socket as SocketBase\nfrom zmq.error import ZMQBindError, ZMQError\nfrom zmq.utils import jsonapi\nfrom zmq.utils.interop import cast_int_addr\n\nfrom ..constants import SocketOption, SocketType, _OptType\nfrom .attrsettr import AttributeSetter\nfrom .poll import Poller\n\ntry:\n    DEFAULT_PROTOCOL = pickle.DEFAULT_PROTOCOL\nexcept AttributeError:\n    DEFAULT_PROTOCOL = pickle.HIGHEST_PROTOCOL\n\nT = TypeVar(\"T\", bound=\"Socket\")\n\n\nclass _SocketContext(Generic[T]):\n    \"\"\"Context Manager for socket bind/unbind\"\"\"\n\n    socket: T\n    kind: str\n    addr: str\n\n    def __repr__(self):\n        return f\"<SocketContext({self.kind}={self.addr!r})>\"\n\n    def __init__(self: \"_SocketContext[T]\", socket: T, kind: str, addr: str):\n        assert kind in {\"bind\", \"connect\"}\n        self.socket = socket\n        self.kind = kind\n        self.addr = addr\n\n    def __enter__(self: \"_SocketContext[T]\") -> T:\n        return self.socket\n\n    def __exit__(self, *args):\n        if self.socket.closed:\n            return\n        if self.kind == \"bind\":\n            self.socket.unbind(self.addr)\n        elif self.kind == \"connect\":\n            self.socket.disconnect(self.addr)\n\n\nST = TypeVar(\"ST\")\n\n\nclass Socket(SocketBase, AttributeSetter, Generic[ST]):\n    \"\"\"The ZMQ socket object\n\n    To create a Socket, first create a Context::\n\n        ctx = zmq.Context.instance()\n\n    then call ``ctx.socket(socket_type)``::\n\n        s = ctx.socket(zmq.ROUTER)\n\n    .. versionadded:: 25\n\n        Sockets can now be shadowed by passing another Socket.\n        This helps in creating an async copy of a sync socket or vice versa::\n\n            s = zmq.Socket(async_socket)\n\n        Which previously had to be::\n\n            s = zmq.Socket.shadow(async_socket.underlying)\n    \"\"\"\n\n    _shadow = False\n    _shadow_obj = None\n    _monitor_socket = None\n    _type_name = 'UNKNOWN'\n\n    @overload\n    def __init__(\n        self: \"Socket[bytes]\",\n        ctx_or_socket: \"zmq.Context\",\n        socket_type: int,\n        *,\n        copy_threshold: Optional[int] = None,\n    ):\n        ...\n\n    @overload\n    def __init__(\n        self: \"Socket[bytes]\",\n        *,\n        shadow: Union[\"Socket\", int],\n        copy_threshold: Optional[int] = None,\n    ):\n        ...\n\n    @overload\n    def __init__(\n        self: \"Socket[bytes]\",\n        ctx_or_socket: \"Socket\",\n    ):\n        ...\n\n    def __init__(\n        self: \"Socket[bytes]\",\n        ctx_or_socket: Optional[Union[\"zmq.Context\", \"Socket\"]] = None,\n        socket_type: int = 0,\n        *,\n        shadow: Union[\"Socket\", int] = 0,\n        copy_threshold: Optional[int] = None,\n    ):\n        if isinstance(ctx_or_socket, zmq.Socket):\n            # positional Socket(other_socket)\n            shadow = ctx_or_socket\n            ctx_or_socket = None\n\n        shadow_address: int = 0\n\n        if shadow:\n            self._shadow = True\n            # hold a reference to the shadow object\n            self._shadow_obj = shadow\n            if not isinstance(shadow, int):\n                try:\n                    shadow = cast(int, shadow.underlying)\n                except AttributeError:\n                    pass\n            shadow_address = cast_int_addr(shadow)\n        else:\n            self._shadow = False\n\n        super().__init__(\n            ctx_or_socket,\n            socket_type,\n            shadow=shadow_address,\n            copy_threshold=copy_threshold,\n        )\n\n        try:\n            socket_type = cast(int, self.get(zmq.TYPE))\n        except Exception:\n            pass\n        else:\n            try:\n                self.__dict__[\"type\"] = stype = SocketType(socket_type)\n            except ValueError:\n                self._type_name = str(socket_type)\n            else:\n                self._type_name = stype.name\n\n    def __del__(self):\n        if not self._shadow and not self.closed:\n            if warn is not None:\n                # warn can be None during process teardown\n                warn(\n                    f\"Unclosed socket {self}\",\n                    ResourceWarning,\n                    stacklevel=2,\n                    source=self,\n                )\n            self.close()\n\n    _repr_cls = \"zmq.Socket\"\n\n    def __repr__(self):\n        cls = self.__class__\n        # look up _repr_cls on exact class, not inherited\n        _repr_cls = cls.__dict__.get(\"_repr_cls\", None)\n        if _repr_cls is None:\n            _repr_cls = f\"{cls.__module__}.{cls.__name__}\"\n\n        closed = ' closed' if self._closed else ''\n\n        return f\"<{_repr_cls}(zmq.{self._type_name}) at {hex(id(self))}{closed}>\"\n\n    # socket as context manager:\n    def __enter__(self: T) -> T:\n        \"\"\"Sockets are context managers\n\n        .. versionadded:: 14.4\n        \"\"\"\n        return self\n\n    def __exit__(self, *args, **kwargs):\n        self.close()\n\n    # -------------------------------------------------------------------------\n    # Socket creation\n    # -------------------------------------------------------------------------\n\n    def __copy__(self: T, memo=None) -> T:\n        \"\"\"Copying a Socket creates a shadow copy\"\"\"\n        return self.__class__.shadow(self.underlying)\n\n    __deepcopy__ = __copy__\n\n    @classmethod\n    def shadow(cls: Type[T], address: Union[int, \"zmq.Socket\"]) -> T:\n        \"\"\"Shadow an existing libzmq socket\n\n        address is a zmq.Socket or an integer (or FFI pointer)\n        representing the address of the libzmq socket.\n\n        .. versionadded:: 14.1\n\n        .. versionadded:: 25\n            Support for shadowing `zmq.Socket` objects,\n            instead of just integer addresses.\n        \"\"\"\n        return cls(shadow=address)\n\n    def close(self, linger=None) -> None:\n        \"\"\"\n        Close the socket.\n\n        If linger is specified, LINGER sockopt will be set prior to closing.\n\n        Note: closing a zmq Socket may not close the underlying sockets\n        if there are undelivered messages.\n        Only after all messages are delivered or discarded by reaching the socket's LINGER timeout\n        (default: forever)\n        will the underlying sockets be closed.\n\n        This can be called to close the socket by hand. If this is not\n        called, the socket will automatically be closed when it is\n        garbage collected,\n        in which case you may see a ResourceWarning about the unclosed socket.\n        \"\"\"\n        if self.context:\n            self.context._rm_socket(self)\n        super().close(linger=linger)\n\n    # -------------------------------------------------------------------------\n    # Connect/Bind context managers\n    # -------------------------------------------------------------------------\n\n    def _connect_cm(self: T, addr: str) -> _SocketContext[T]:\n        \"\"\"Context manager to disconnect on exit\n\n        .. versionadded:: 20.0\n        \"\"\"\n        return _SocketContext(self, 'connect', addr)\n\n    def _bind_cm(self: T, addr: str) -> _SocketContext[T]:\n        \"\"\"Context manager to unbind on exit\n\n        .. versionadded:: 20.0\n        \"\"\"\n        return _SocketContext(self, 'bind', addr)\n\n    def bind(self: T, addr: str) -> _SocketContext[T]:\n        \"\"\"s.bind(addr)\n\n        Bind the socket to an address.\n\n        This causes the socket to listen on a network port. Sockets on the\n        other side of this connection will use ``Socket.connect(addr)`` to\n        connect to this socket.\n\n        Returns a context manager which will call unbind on exit.\n\n        .. versionadded:: 20.0\n            Can be used as a context manager.\n\n        Parameters\n        ----------\n        addr : str\n            The address string. This has the form 'protocol://interface:port',\n            for example 'tcp://127.0.0.1:5555'. Protocols supported include\n            tcp, udp, pgm, epgm, inproc and ipc. If the address is unicode, it is\n            encoded to utf-8 first.\n\n        \"\"\"\n        try:\n            super().bind(addr)\n        except ZMQError as e:\n            e.strerror += f\" (addr={addr!r})\"\n            raise\n        return self._bind_cm(addr)\n\n    def connect(self: T, addr: str) -> _SocketContext[T]:\n        \"\"\"s.connect(addr)\n\n        Connect to a remote 0MQ socket.\n\n        Returns a context manager which will call disconnect on exit.\n\n        .. versionadded:: 20.0\n            Can be used as a context manager.\n\n        Parameters\n        ----------\n        addr : str\n            The address string. This has the form 'protocol://interface:port',\n            for example 'tcp://127.0.0.1:5555'. Protocols supported are\n            tcp, udp, pgm, inproc and ipc. If the address is unicode, it is\n            encoded to utf-8 first.\n\n        \"\"\"\n        try:\n            super().connect(addr)\n        except ZMQError as e:\n            e.strerror += f\" (addr={addr!r})\"\n            raise\n        return self._connect_cm(addr)\n\n    # -------------------------------------------------------------------------\n    # Deprecated aliases\n    # -------------------------------------------------------------------------\n\n    @property\n    def socket_type(self) -> int:\n        warn(\"Socket.socket_type is deprecated, use Socket.type\", DeprecationWarning)\n        return cast(int, self.type)\n\n    # -------------------------------------------------------------------------\n    # Hooks for sockopt completion\n    # -------------------------------------------------------------------------\n\n    def __dir__(self):\n        keys = dir(self.__class__)\n        keys.extend(SocketOption.__members__)\n        return keys\n\n    # -------------------------------------------------------------------------\n    # Getting/Setting options\n    # -------------------------------------------------------------------------\n    setsockopt = SocketBase.set\n    getsockopt = SocketBase.get\n\n    def __setattr__(self, key, value):\n        \"\"\"Override to allow setting zmq.[UN]SUBSCRIBE even though we have a subscribe method\"\"\"\n        if key in self.__dict__:\n            object.__setattr__(self, key, value)\n            return\n        _key = key.lower()\n        if _key in ('subscribe', 'unsubscribe'):\n            if isinstance(value, str):\n                value = value.encode('utf8')\n            if _key == 'subscribe':\n                self.set(zmq.SUBSCRIBE, value)\n            else:\n                self.set(zmq.UNSUBSCRIBE, value)\n            return\n        super().__setattr__(key, value)\n\n    def fileno(self) -> int:\n        \"\"\"Return edge-triggered file descriptor for this socket.\n\n        This is a read-only edge-triggered file descriptor for both read and write events on this socket.\n        It is important that all available events be consumed when an event is detected,\n        otherwise the read event will not trigger again.\n\n        .. versionadded:: 17.0\n        \"\"\"\n        return self.FD\n\n    def subscribe(self, topic: Union[str, bytes]) -> None:\n        \"\"\"Subscribe to a topic\n\n        Only for SUB sockets.\n\n        .. versionadded:: 15.3\n        \"\"\"\n        if isinstance(topic, str):\n            topic = topic.encode('utf8')\n        self.set(zmq.SUBSCRIBE, topic)\n\n    def unsubscribe(self, topic: Union[str, bytes]) -> None:\n        \"\"\"Unsubscribe from a topic\n\n        Only for SUB sockets.\n\n        .. versionadded:: 15.3\n        \"\"\"\n        if isinstance(topic, str):\n            topic = topic.encode('utf8')\n        self.set(zmq.UNSUBSCRIBE, topic)\n\n    def set_string(self, option: int, optval: str, encoding='utf-8') -> None:\n        \"\"\"Set socket options with a unicode object.\n\n        This is simply a wrapper for setsockopt to protect from encoding ambiguity.\n\n        See the 0MQ documentation for details on specific options.\n\n        Parameters\n        ----------\n        option : int\n            The name of the option to set. Can be any of: SUBSCRIBE,\n            UNSUBSCRIBE, IDENTITY\n        optval : str\n            The value of the option to set.\n        encoding : str\n            The encoding to be used, default is utf8\n        \"\"\"\n        if not isinstance(optval, str):\n            raise TypeError(f\"strings only, not {type(optval)}: {optval!r}\")\n        return self.set(option, optval.encode(encoding))\n\n    setsockopt_unicode = setsockopt_string = set_string\n\n    def get_string(self, option: int, encoding='utf-8') -> str:\n        \"\"\"Get the value of a socket option.\n\n        See the 0MQ documentation for details on specific options.\n\n        Parameters\n        ----------\n        option : int\n            The option to retrieve.\n\n        Returns\n        -------\n        optval : str\n            The value of the option as a unicode string.\n        \"\"\"\n        if SocketOption(option)._opt_type != _OptType.bytes:\n            raise TypeError(f\"option {option} will not return a string to be decoded\")\n        return cast(bytes, self.get(option)).decode(encoding)\n\n    getsockopt_unicode = getsockopt_string = get_string\n\n    def bind_to_random_port(\n        self: T,\n        addr: str,\n        min_port: int = 49152,\n        max_port: int = 65536,\n        max_tries: int = 100,\n    ) -> int:\n        \"\"\"Bind this socket to a random port in a range.\n\n        If the port range is unspecified, the system will choose the port.\n\n        Parameters\n        ----------\n        addr : str\n            The address string without the port to pass to ``Socket.bind()``.\n        min_port : int, optional\n            The minimum port in the range of ports to try (inclusive).\n        max_port : int, optional\n            The maximum port in the range of ports to try (exclusive).\n        max_tries : int, optional\n            The maximum number of bind attempts to make.\n\n        Returns\n        -------\n        port : int\n            The port the socket was bound to.\n\n        Raises\n        ------\n        ZMQBindError\n            if `max_tries` reached before successful bind\n        \"\"\"\n        if (\n            (zmq.zmq_version_info() >= (3, 2))\n            and min_port == 49152\n            and max_port == 65536\n        ):\n            # if LAST_ENDPOINT is supported, and min_port / max_port weren't specified,\n            # we can bind to port 0 and let the OS do the work\n            self.bind(\"%s:*\" % addr)\n            url = cast(bytes, self.last_endpoint).decode('ascii', 'replace')\n            _, port_s = url.rsplit(':', 1)\n            return int(port_s)\n\n        for i in range(max_tries):\n            try:\n                port = random.randrange(min_port, max_port)\n                self.bind(f'{addr}:{port}')\n            except ZMQError as exception:\n                en = exception.errno\n                if en == zmq.EADDRINUSE:\n                    continue\n                elif sys.platform == 'win32' and en == errno.EACCES:\n                    continue\n                else:\n                    raise\n            else:\n                return port\n        raise ZMQBindError(\"Could not bind socket to random port.\")\n\n    def get_hwm(self) -> int:\n        \"\"\"Get the High Water Mark.\n\n        On libzmq \u2265 3, this gets SNDHWM if available, otherwise RCVHWM\n        \"\"\"\n        major = zmq.zmq_version_info()[0]\n        if major >= 3:\n            # return sndhwm, fallback on rcvhwm\n            try:\n                return cast(int, self.get(zmq.SNDHWM))\n            except zmq.ZMQError:\n                pass\n\n            return cast(int, self.get(zmq.RCVHWM))\n        else:\n            return cast(int, self.get(zmq.HWM))\n\n    def set_hwm(self, value: int) -> None:\n        \"\"\"Set the High Water Mark.\n\n        On libzmq \u2265 3, this sets both SNDHWM and RCVHWM\n\n\n        .. warning::\n\n            New values only take effect for subsequent socket\n            bind/connects.\n        \"\"\"\n        major = zmq.zmq_version_info()[0]\n        if major >= 3:\n            raised = None\n            try:\n                self.sndhwm = value\n            except Exception as e:\n                raised = e\n            try:\n                self.rcvhwm = value\n            except Exception as e:\n                raised = e\n\n            if raised:\n                raise raised\n        else:\n            self.set(zmq.HWM, value)\n\n    hwm = property(\n        get_hwm,\n        set_hwm,\n        None,\n        \"\"\"Property for High Water Mark.\n\n        Setting hwm sets both SNDHWM and RCVHWM as appropriate.\n        It gets SNDHWM if available, otherwise RCVHWM.\n        \"\"\",\n    )\n\n    # -------------------------------------------------------------------------\n    # Sending and receiving messages\n    # -------------------------------------------------------------------------\n\n    @overload\n    def send(\n        self,\n        data: Any,\n        flags: int = ...,\n        copy: bool = ...,\n        *,\n        track: Literal[True],\n        routing_id: Optional[int] = ...,\n        group: Optional[str] = ...,\n    ) -> \"zmq.MessageTracker\":\n        ...\n\n    @overload\n    def send(\n        self,\n        data: Any,\n        flags: int = ...,\n        copy: bool = ...,\n        *,\n        track: Literal[False],\n        routing_id: Optional[int] = ...,\n        group: Optional[str] = ...,\n    ) -> None:\n        ...\n\n    @overload\n    def send(\n        self,\n        data: Any,\n        flags: int = ...,\n        *,\n        copy: bool = ...,\n        routing_id: Optional[int] = ...,\n        group: Optional[str] = ...,\n    ) -> None:\n        ...\n\n    @overload\n    def send(\n        self,\n        data: Any,\n        flags: int = ...,\n        copy: bool = ...,\n        track: bool = ...,\n        routing_id: Optional[int] = ...,\n        group: Optional[str] = ...,\n    ) -> Optional[\"zmq.MessageTracker\"]:\n        ...\n\n    def send(\n        self,\n        data: Any,\n        flags: int = 0,\n        copy: bool = True,\n        track: bool = False,\n        routing_id: Optional[int] = None,\n        group: Optional[str] = None,\n    ) -> Optional[\"zmq.MessageTracker\"]:\n        \"\"\"Send a single zmq message frame on this socket.\n\n        This queues the message to be sent by the IO thread at a later time.\n\n        With flags=NOBLOCK, this raises :class:`ZMQError` if the queue is full;\n        otherwise, this waits until space is available.\n        See :class:`Poller` for more general non-blocking I/O.\n\n        Parameters\n        ----------\n        data : bytes, Frame, memoryview\n            The content of the message. This can be any object that provides\n            the Python buffer API (i.e. `memoryview(data)` can be called).\n        flags : int\n            0, NOBLOCK, SNDMORE, or NOBLOCK|SNDMORE.\n        copy : bool\n            Should the message be sent in a copying or non-copying manner.\n        track : bool\n            Should the message be tracked for notification that ZMQ has\n            finished with it? (ignored if copy=True)\n        routing_id : int\n            For use with SERVER sockets\n        group : str\n            For use with RADIO sockets\n\n        Returns\n        -------\n        None : if `copy` or not track\n            None if message was sent, raises an exception otherwise.\n        MessageTracker : if track and not copy\n            a MessageTracker object, whose `pending` property will\n            be True until the send is completed.\n\n        Raises\n        ------\n        TypeError\n            If a unicode object is passed\n        ValueError\n            If `track=True`, but an untracked Frame is passed.\n        ZMQError\n            If the send does not succeed for any reason (including\n            if NOBLOCK is set and the outgoing queue is full).\n\n\n        .. versionchanged:: 17.0\n\n            DRAFT support for routing_id and group arguments.\n        \"\"\"\n        if routing_id is not None:\n            if not isinstance(data, zmq.Frame):\n                data = zmq.Frame(\n                    data,\n                    track=track,\n                    copy=copy or None,\n                    copy_threshold=self.copy_threshold,\n                )\n            data.routing_id = routing_id\n        if group is not None:\n            if not isinstance(data, zmq.Frame):\n                data = zmq.Frame(\n                    data,\n                    track=track,\n                    copy=copy or None,\n                    copy_threshold=self.copy_threshold,\n                )\n            data.group = group\n        return super().send(data, flags=flags, copy=copy, track=track)\n\n    def send_multipart(\n        self,\n        msg_parts: Sequence,\n        flags: int = 0,\n        copy: bool = True,\n        track: bool = False,\n        **kwargs,\n    ):\n        \"\"\"Send a sequence of buffers as a multipart message.\n\n        The zmq.SNDMORE flag is added to all msg parts before the last.\n\n        Parameters\n        ----------\n        msg_parts : iterable\n            A sequence of objects to send as a multipart message. Each element\n            can be any sendable object (Frame, bytes, buffer-providers)\n        flags : int, optional\n            Any valid flags for :func:`Socket.send`.\n            SNDMORE is added automatically for frames before the last.\n        copy : bool, optional\n            Should the frame(s) be sent in a copying or non-copying manner.\n            If copy=False, frames smaller than self.copy_threshold bytes\n            will be copied anyway.\n        track : bool, optional\n            Should the frame(s) be tracked for notification that ZMQ has\n            finished with it (ignored if copy=True).\n\n        Returns\n        -------\n        None : if copy or not track\n        MessageTracker : if track and not copy\n            a MessageTracker object, whose `pending` property will\n            be True until the last send is completed.\n        \"\"\"\n        # typecheck parts before sending:\n        for i, msg in enumerate(msg_parts):\n            if isinstance(msg, (zmq.Frame, bytes, memoryview)):\n                continue\n            try:\n                memoryview(msg)\n            except Exception:\n                rmsg = repr(msg)\n                if len(rmsg) > 32:\n                    rmsg = rmsg[:32] + '...'\n                raise TypeError(\n                    \"Frame %i (%s) does not support the buffer interface.\"\n                    % (\n                        i,\n                        rmsg,\n                    )\n                )\n        for msg in msg_parts[:-1]:\n            self.send(msg, zmq.SNDMORE | flags, copy=copy, track=track)\n        # Send the last part without the extra SNDMORE flag.\n        return self.send(msg_parts[-1], flags, copy=copy, track=track)\n\n    @overload\n    def recv_multipart(\n        self, flags: int = ..., *, copy: Literal[True], track: bool = ...\n    ) -> List[bytes]:\n        ...\n\n    @overload\n    def recv_multipart(\n        self, flags: int = ..., *, copy: Literal[False], track: bool = ...\n    ) -> List[zmq.Frame]:\n        ...\n\n    @overload\n    def recv_multipart(self, flags: int = ..., *, track: bool = ...) -> List[bytes]:\n        ...\n\n    @overload\n    def recv_multipart(\n        self, flags: int = 0, copy: bool = True, track: bool = False\n    ) -> Union[List[zmq.Frame], List[bytes]]:\n        ...\n\n    def recv_multipart(\n        self, flags: int = 0, copy: bool = True, track: bool = False\n    ) -> Union[List[zmq.Frame], List[bytes]]:\n        \"\"\"Receive a multipart message as a list of bytes or Frame objects\n\n        Parameters\n        ----------\n        flags : int, optional\n            Any valid flags for :func:`Socket.recv`.\n        copy : bool, optional\n            Should the message frame(s) be received in a copying or non-copying manner?\n            If False a Frame object is returned for each part, if True a copy of\n            the bytes is made for each frame.\n        track : bool, optional\n            Should the message frame(s) be tracked for notification that ZMQ has\n            finished with it? (ignored if copy=True)\n\n        Returns\n        -------\n        msg_parts : list\n            A list of frames in the multipart message; either Frames or bytes,\n            depending on `copy`.\n\n        Raises\n        ------\n        ZMQError\n            for any of the reasons :func:`~Socket.recv` might fail\n        \"\"\"\n        parts = [self.recv(flags, copy=copy, track=track)]\n        # have first part already, only loop while more to receive\n        while self.getsockopt(zmq.RCVMORE):\n            part = self.recv(flags, copy=copy, track=track)\n            parts.append(part)\n        # cast List[Union] to Union[List]\n        # how do we get mypy to recognize that return type is invariant on `copy`?\n        return cast(Union[List[zmq.Frame], List[bytes]], parts)\n\n    def _deserialize(\n        self,\n        recvd: bytes,\n        load: Callable[[bytes], Any],\n    ) -> Any:\n        \"\"\"Deserialize a received message\n\n        Override in subclass (e.g. Futures) if recvd is not the raw bytes.\n\n        The default implementation expects bytes and returns the deserialized message immediately.\n\n        Parameters\n        ----------\n\n        load: callable\n            Callable that deserializes bytes\n        recvd:\n            The object returned by self.recv\n\n        \"\"\"\n        return load(recvd)\n\n    def send_serialized(self, msg, serialize, flags=0, copy=True, **kwargs):\n        \"\"\"Send a message with a custom serialization function.\n\n        .. versionadded:: 17\n\n        Parameters\n        ----------\n        msg : The message to be sent. Can be any object serializable by `serialize`.\n        serialize : callable\n            The serialization function to use.\n            serialize(msg) should return an iterable of sendable message frames\n            (e.g. bytes objects), which will be passed to send_multipart.\n        flags : int, optional\n            Any valid flags for :func:`Socket.send`.\n        copy : bool, optional\n            Whether to copy the frames.\n\n        \"\"\"\n        frames = serialize(msg)\n        return self.send_multipart(frames, flags=flags, copy=copy, **kwargs)\n\n    def recv_serialized(self, deserialize, flags=0, copy=True):\n        \"\"\"Receive a message with a custom deserialization function.\n\n        .. versionadded:: 17\n\n        Parameters\n        ----------\n        deserialize : callable\n            The deserialization function to use.\n            deserialize will be called with one argument: the list of frames\n            returned by recv_multipart() and can return any object.\n        flags : int, optional\n            Any valid flags for :func:`Socket.recv`.\n        copy : bool, optional\n            Whether to recv bytes or Frame objects.\n\n        Returns\n        -------\n        obj : object\n            The object returned by the deserialization function.\n\n        Raises\n        ------\n        ZMQError\n            for any of the reasons :func:`~Socket.recv` might fail\n        \"\"\"\n        frames = self.recv_multipart(flags=flags, copy=copy)\n        return self._deserialize(frames, deserialize)\n\n    def send_string(\n        self,\n        u: str,\n        flags: int = 0,\n        copy: bool = True,\n        encoding: str = 'utf-8',\n        **kwargs,\n    ) -> Optional[\"zmq.Frame\"]:\n        \"\"\"Send a Python unicode string as a message with an encoding.\n\n        0MQ communicates with raw bytes, so you must encode/decode\n        text (str) around 0MQ.\n\n        Parameters\n        ----------\n        u : str\n            The unicode string to send.\n        flags : int, optional\n            Any valid flags for :func:`Socket.send`.\n        encoding : str [default: 'utf-8']\n            The encoding to be used\n        \"\"\"\n        if not isinstance(u, str):\n            raise TypeError(\"str objects only\")\n        return self.send(u.encode(encoding), flags=flags, copy=copy, **kwargs)\n\n    send_unicode = send_string\n\n    def recv_string(self, flags: int = 0, encoding: str = 'utf-8') -> str:\n        \"\"\"Receive a unicode string, as sent by send_string.\n\n        Parameters\n        ----------\n        flags : int\n            Any valid flags for :func:`Socket.recv`.\n        encoding : str [default: 'utf-8']\n            The encoding to be used\n\n        Returns\n        -------\n        s : str\n            The Python unicode string that arrives as encoded bytes.\n\n        Raises\n        ------\n        ZMQError\n            for any of the reasons :func:`~Socket.recv` might fail\n        \"\"\"\n        msg = self.recv(flags=flags)\n        return self._deserialize(msg, lambda buf: buf.decode(encoding))\n\n    recv_unicode = recv_string\n\n    def send_pyobj(\n        self, obj: Any, flags: int = 0, protocol: int = DEFAULT_PROTOCOL, **kwargs\n    ) -> Optional[zmq.Frame]:\n        \"\"\"Send a Python object as a message using pickle to serialize.\n\n        Parameters\n        ----------\n        obj : Python object\n            The Python object to send.\n        flags : int\n            Any valid flags for :func:`Socket.send`.\n        protocol : int\n            The pickle protocol number to use. The default is pickle.DEFAULT_PROTOCOL\n            where defined, and pickle.HIGHEST_PROTOCOL elsewhere.\n        \"\"\"\n        msg = pickle.dumps(obj, protocol)\n        return self.send(msg, flags=flags, **kwargs)\n\n    def recv_pyobj(self, flags: int = 0) -> Any:\n        \"\"\"Receive a Python object as a message using pickle to serialize.\n\n        Parameters\n        ----------\n        flags : int\n            Any valid flags for :func:`Socket.recv`.\n\n        Returns\n        -------\n        obj : Python object\n            The Python object that arrives as a message.\n\n        Raises\n        ------\n        ZMQError\n            for any of the reasons :func:`~Socket.recv` might fail\n        \"\"\"\n        msg = self.recv(flags)\n        return self._deserialize(msg, pickle.loads)\n\n    def send_json(self, obj: Any, flags: int = 0, **kwargs) -> None:\n        \"\"\"Send a Python object as a message using json to serialize.\n\n        Keyword arguments are passed on to json.dumps\n\n        Parameters\n        ----------\n        obj : Python object\n            The Python object to send\n        flags : int\n            Any valid flags for :func:`Socket.send`\n        \"\"\"\n        send_kwargs = {}\n        for key in ('routing_id', 'group'):\n            if key in kwargs:\n                send_kwargs[key] = kwargs.pop(key)\n        msg = jsonapi.dumps(obj, **kwargs)\n        return self.send(msg, flags=flags, **send_kwargs)\n\n    def recv_json(self, flags: int = 0, **kwargs) -> Union[List, str, int, float, Dict]:\n        \"\"\"Receive a Python object as a message using json to serialize.\n\n        Keyword arguments are passed on to json.loads\n\n        Parameters\n        ----------\n        flags : int\n            Any valid flags for :func:`Socket.recv`.\n\n        Returns\n        -------\n        obj : Python object\n            The Python object that arrives as a message.\n\n        Raises\n        ------\n        ZMQError\n            for any of the reasons :func:`~Socket.recv` might fail\n        \"\"\"\n        msg = self.recv(flags)\n        return self._deserialize(msg, lambda buf: jsonapi.loads(buf, **kwargs))\n\n    _poller_class = Poller\n\n    def poll(self, timeout=None, flags=zmq.POLLIN) -> int:\n        \"\"\"Poll the socket for events.\n        See :class:`Poller` to wait for multiple sockets at once.\n\n        Parameters\n        ----------\n        timeout : int [default: None]\n            The timeout (in milliseconds) to wait for an event. If unspecified\n            (or specified None), will wait forever for an event.\n        flags : int [default: POLLIN]\n            POLLIN, POLLOUT, or POLLIN|POLLOUT. The event flags to poll for.\n\n        Returns\n        -------\n        event_mask : int\n            The poll event mask (POLLIN, POLLOUT),\n            0 if the timeout was reached without an event.\n        \"\"\"\n\n        if self.closed:\n            raise ZMQError(zmq.ENOTSUP)\n\n        p = self._poller_class()\n        p.register(self, flags)\n        evts = dict(p.poll(timeout))\n        # return 0 if no events, otherwise return event bitfield\n        return evts.get(self, 0)\n\n    def get_monitor_socket(\n        self: T, events: Optional[int] = None, addr: Optional[str] = None\n    ) -> T:\n        \"\"\"Return a connected PAIR socket ready to receive the event notifications.\n\n        .. versionadded:: libzmq-4.0\n        .. versionadded:: 14.0\n\n        Parameters\n        ----------\n        events : int [default: ZMQ_EVENT_ALL]\n            The bitmask defining which events are wanted.\n        addr :  string [default: None]\n            The optional endpoint for the monitoring sockets.\n\n        Returns\n        -------\n        socket :  (PAIR)\n            The socket is already connected and ready to receive messages.\n        \"\"\"\n        # safe-guard, method only available on libzmq >= 4\n        if zmq.zmq_version_info() < (4,):\n            raise NotImplementedError(\n                \"get_monitor_socket requires libzmq >= 4, have %s\" % zmq.zmq_version()\n            )\n\n        # if already monitoring, return existing socket\n        if self._monitor_socket:\n            if self._monitor_socket.closed:\n                self._monitor_socket = None\n            else:\n                return self._monitor_socket\n\n        if addr is None:\n            # create endpoint name from internal fd\n            addr = f\"inproc://monitor.s-{self.FD}\"\n        if events is None:\n            # use all events\n            events = zmq.EVENT_ALL\n        # attach monitoring socket\n        self.monitor(addr, events)\n        # create new PAIR socket and connect it\n        self._monitor_socket = self.context.socket(zmq.PAIR)\n        self._monitor_socket.connect(addr)\n        return self._monitor_socket\n\n    def disable_monitor(self) -> None:\n        \"\"\"Shutdown the PAIR socket (created using get_monitor_socket)\n        that is serving socket events.\n\n        .. versionadded:: 14.4\n        \"\"\"\n        self._monitor_socket = None\n        self.monitor(None, 0)\n\n\n__all__ = ['Socket']\n", 1106]}, "functions": {"OutStream._is_master_process (/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py:519)": ["/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py", 519], "Event.is_set (/opt/anaconda3/lib/python3.12/threading.py:601)": ["/opt/anaconda3/lib/python3.12/threading.py", 601], "Thread._wait_for_tstate_lock (/opt/anaconda3/lib/python3.12/threading.py:1155)": ["/opt/anaconda3/lib/python3.12/threading.py", 1155], "Thread.is_alive (/opt/anaconda3/lib/python3.12/threading.py:1222)": ["/opt/anaconda3/lib/python3.12/threading.py", 1222], "IOPubThread._event_pipe (/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py:137)": ["/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py", 137], "IOPubThread.closed (/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py:254)": ["/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py", 254], "IOPubThread._is_master_process (/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py:212)": ["/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py", 212], "IOPubThread._check_mp_mode (/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py:215)": ["/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py", 215], "Flag._get_value (/opt/anaconda3/lib/python3.12/enum.py:1544)": ["/opt/anaconda3/lib/python3.12/enum.py", 1544], "Enum.__new__ (/opt/anaconda3/lib/python3.12/enum.py:1129)": ["/opt/anaconda3/lib/python3.12/enum.py", 1129], "EnumType.__call__ (/opt/anaconda3/lib/python3.12/enum.py:726)": ["/opt/anaconda3/lib/python3.12/enum.py", 726], "Flag.__or__ (/opt/anaconda3/lib/python3.12/enum.py:1551)": ["/opt/anaconda3/lib/python3.12/enum.py", 1551], "Socket.send (/opt/anaconda3/lib/python3.12/site-packages/zmq/sugar/socket.py:621)": ["/opt/anaconda3/lib/python3.12/site-packages/zmq/sugar/socket.py", 621], "IOPubThread.schedule (/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py:258)": ["/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py", 258], "OutStream._schedule_flush (/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py:546)": ["/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py", 546], "OutStream.write (/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py:624)": ["/opt/anaconda3/lib/python3.12/site-packages/ipykernel/iostream.py", 624]}}}